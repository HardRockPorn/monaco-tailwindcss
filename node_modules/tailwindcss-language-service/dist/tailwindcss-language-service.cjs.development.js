'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var dlv = _interopDefault(require('dlv'));
var culori = require('culori');
var namedColors = _interopDefault(require('color-name'));
var lineColumn = _interopDefault(require('line-column'));
var moo = _interopDefault(require('moo'));
var Regex = _interopDefault(require('becke-ch--regex--s0-0-v1--base--pl--lib'));
var Cache = _interopDefault(require('tmp-cache'));
var escapeClassName = _interopDefault(require('css.escape'));
var stringifyObject = _interopDefault(require('stringify-object'));
var emmetHelper = require('vscode-emmet-helper-bundled');
var semverGte = _interopDefault(require('semver/functions/gte'));
require('semver/functions/lte');
var sift = _interopDefault(require('sift-string'));
var detectIndent = _interopDefault(require('detect-indent'));
var dset = require('dset');
var selectorParser = _interopDefault(require('postcss-selector-parser'));

function isObject(variable) {
  return Object.prototype.toString.call(variable) === '[object Object]';
}

function removeMeta(obj) {
  let result = {};
  for (let key in obj) {
    if (key.substr(0, 2) === '__') continue;
    if (isObject(obj[key])) {
      result[key] = removeMeta(obj[key]);
    } else {
      result[key] = obj[key];
    }
  }
  return result;
}

function rangesEqual(a, b) {
  return a.start.line === b.start.line && a.start.character === b.start.character && a.end.line === b.end.line && a.end.character === b.end.character;
}

function dedupe(arr) {
  return arr.filter((value, index, self) => self.indexOf(value) === index);
}
function dedupeBy(arr, transform) {
  return arr.filter((value, index, self) => self.map(transform).indexOf(transform(value)) === index);
}
function dedupeByRange(arr) {
  return arr.filter((classList, classListIndex) => classListIndex === arr.findIndex(c => rangesEqual(c.range, classList.range)));
}
function ensureArray(value) {
  return Array.isArray(value) ? value : [value];
}
function flatten(arrays) {
  return [].concat.apply([], arrays);
}
function equal(a, b) {
  if (a === b) return true;
  if (a.length !== b.length) return false;
  let aSorted = a.concat().sort();
  let bSorted = b.concat().sort();
  for (let i = 0; i < aSorted.length; ++i) {
    if (aSorted[i] !== bSorted[i]) return false;
  }
  return true;
}
function equalExact(a, b) {
  if (a === b) return true;
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}

function combinations(str) {
  let fn = function (active, rest, a) {
    if (!active && !rest) return undefined;
    if (!rest) {
      a.push(active);
    } else {
      fn(active + rest[0], rest.slice(1), a);
      fn(active, rest.slice(1), a);
    }
    return a;
  };
  return fn('', str, []);
}

function getClassNameParts(state, className) {
  let separator = state.separator;
  className = className.replace(/^\./, '');
  let parts = className.split(separator);
  if (parts.length === 1) {
    return dlv(state.classNames.classNames, [className, '__info', '__rule']) === true || Array.isArray(dlv(state.classNames.classNames, [className, '__info'])) ? [className] : null;
  }
  let points = combinations('123456789'.substr(0, parts.length - 1)).map(x => x.split('').map(x => parseInt(x, 10)));
  let possibilities = [[className], ...points.map(p => {
    let result = [];
    let i = 0;
    p.forEach(x => {
      result.push(parts.slice(i, x).join('-'));
      i = x;
    });
    result.push(parts.slice(i).join('-'));
    return result;
  })];
  return possibilities.find(key => {
    if (dlv(state.classNames.classNames, [...key, '__info', '__rule']) === true || Array.isArray(dlv(state.classNames.classNames, [...key, '__info']))) {
      return true;
    }
    return false;
  });
}

function remToPx(value, rootSize) {
  if (rootSize === void 0) {
    rootSize = 16;
  }
  if (/^-?[0-9.]+rem$/.test(value)) {
    let number = parseFloat(value.substr(0, value.length - 3));
    if (!isNaN(number)) {
      return `${number * rootSize}px`;
    }
  }
  return undefined;
}

function bigSign(bigIntValue) {
  // @ts-ignore
  return (bigIntValue > 0n) - (bigIntValue < 0n);
}
function generateRules(state, classNames) {
  let rules = state.modules.jit.generateRules.module(new Set(classNames), state.jitContext).sort((_ref, _ref2) => {
    let [a] = _ref;
    let [z] = _ref2;
    return bigSign(a - z);
  });
  let root = state.modules.postcss.module.root({
    nodes: rules.map(_ref3 => {
      let [, rule] = _ref3;
      return rule;
    })
  });
  state.modules.jit.expandApplyAtRules.module(state.jitContext)(root);
  let actualRules = [];
  root.walkRules(subRule => {
    actualRules.push(subRule);
  });
  return {
    root,
    rules: actualRules
  };
}
async function stringifyRoot(state, root, uri) {
  let settings = await state.editor.getConfiguration(uri);
  let clone = root.clone();
  clone.walkAtRules('defaults', node => {
    node.remove();
  });
  if (settings.tailwindCSS.showPixelEquivalents) {
    clone.walkDecls(decl => {
      let px = remToPx(decl.value, settings.tailwindCSS.rootFontSize);
      if (px) {
        decl.value = `${decl.value}/* ${px} */`;
      }
    });
  }
  return clone.toString().replace(/([^;{}\s])(\n\s*})/g, (_match, before, after) => `${before};${after}`).replace(/^(?:    )+/gm, indent => ' '.repeat(indent.length / 4 * settings.editor.tabSize));
}
async function stringifyDecls(state, rule, uri) {
  let settings = await state.editor.getConfiguration(uri);
  let result = [];
  rule.walkDecls(_ref4 => {
    let {
      prop,
      value
    } = _ref4;
    let px = settings.tailwindCSS.showPixelEquivalents ? remToPx(value, settings.tailwindCSS.rootFontSize) : undefined;
    result.push(`${prop}: ${value}${px ? `/* ${px} */` : ''};`);
  });
  return result.join(' ');
}
function replaceClassName(state, selector, find, replace) {
  const transform = selectors => {
    selectors.walkClasses(className => {
      if (className.value === find) {
        className.value = replace;
      }
    });
  };
  return state.modules.postcssSelectorParser.module(transform).processSync(selector);
}
function getRuleContext(state, rule, className) {
  let context = [replaceClassName(state, rule.selector, className, '__placeholder__')];
  let p = rule;
  while (p.parent && p.parent.type !== 'root') {
    p = p.parent;
    if (p.type === 'atrule') {
      // @ts-ignore
      context.unshift(`@${p.name} ${p.params}`);
    }
  }
  return context;
}

const COLOR_PROPS = ['accent-color', 'caret-color', 'color', 'column-rule-color', 'background-color', 'border-color', 'border-top-color', 'border-right-color', 'border-bottom-color', 'border-left-color', 'fill', 'outline-color', 'stop-color', 'stroke', 'text-decoration-color'];
function getKeywordColor(value) {
  if (typeof value !== 'string') return null;
  let lowercased = value.toLowerCase();
  if (lowercased === 'transparent') {
    return 'transparent';
  }
  if (lowercased === 'currentcolor') {
    return 'currentColor';
  }
  return null;
}
// https://github.com/khalilgharbaoui/coloregex
const colorRegex = /*#__PURE__*/new RegExp(`(?:^|\\s|\\(|,)(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\\(\\s*(-?[\\d.]+%?(\\s*[,/]\\s*|\\s+)+){2,3}\\s*([\\d.]+%?|var\\([^)]+\\))?\\)|transparent|currentColor|${/*#__PURE__*/Object.keys(namedColors).join('|')})(?:$|\\s|\\)|,)`, 'gi');
function replaceColorVarsWithTheirDefaults(str) {
  // rgb(var(--primary, 66 66 66))
  // -> rgb(66 66 66)
  return str.replace(/((?:rgb|hsl)a?\(\s*)var\([^,]+,\s*([^)]+)\)/gi, '$1$2');
}
function getColorsInString(str) {
  if (/(?:box|drop)-shadow/.test(str)) return [];
  return Array.from(replaceColorVarsWithTheirDefaults(str).matchAll(colorRegex), match => {
    var _getKeywordColor;
    let color = match[1].replace(/var\([^)]+\)/, '1');
    return (_getKeywordColor = getKeywordColor(color)) != null ? _getKeywordColor : culori.parse(color);
  }).filter(Boolean);
}
function getColorFromDecls(decls) {
  let props = Object.keys(decls).filter(prop => {
    // ignore content: "";
    if (prop === 'content' && (decls[prop] === '""' || decls[prop] === "''" || decls[prop] === 'var(--tw-content)')) {
      return false;
    }
    return true;
  });
  if (props.length === 0) return null;
  const nonCustomProps = props.filter(prop => !prop.startsWith('--'));
  const areAllCustom = nonCustomProps.length === 0;
  if (!areAllCustom && nonCustomProps.some(prop => !COLOR_PROPS.includes(prop))) {
    // they should all be color-based props
    return null;
  }
  const propsToCheck = areAllCustom ? props : nonCustomProps;
  const colors = propsToCheck.flatMap(prop => ensureArray(decls[prop]).flatMap(getColorsInString));
  // check that all of the values are valid colors
  // if (colors.some((color) => color instanceof TinyColor && !color.isValid)) {
  //   return null
  // }
  // check that all of the values are the same color, ignoring alpha
  const colorStrings = dedupe(colors.map(color => typeof color === 'string' ? color : culori.formatRgb({
    ...color,
    alpha: undefined
  })));
  if (colorStrings.length !== 1) {
    return null;
  }
  let keyword = getKeywordColor(colorStrings[0]);
  if (keyword) {
    return keyword;
  }
  const nonKeywordColors = colors.filter(color => typeof color !== 'string');
  const alphas = dedupe(nonKeywordColors.map(color => {
    var _color$alpha;
    return (_color$alpha = color.alpha) != null ? _color$alpha : 1;
  }));
  if (alphas.length === 1) {
    return nonKeywordColors[0];
  }
  if (alphas.length === 2 && alphas.includes(0)) {
    return nonKeywordColors.find(color => {
      var _color$alpha2;
      return ((_color$alpha2 = color.alpha) != null ? _color$alpha2 : 1) !== 0;
    });
  }
  return null;
}
function getColor(state, className) {
  if (state.jit) {
    if (state.classNames) {
      const item = dlv(state.classNames.classNames, [className, '__info']);
      if (item && item.__rule) {
        return getColorFromDecls(removeMeta(item));
      }
    }
    let {
      root,
      rules
    } = generateRules(state, [className]);
    if (rules.length === 0) return null;
    let decls = {};
    root.walkDecls(decl => {
      let value = decls[decl.prop];
      if (value) {
        if (Array.isArray(value)) {
          value.push(decl.value);
        } else {
          decls[decl.prop] = [value, decl.value];
        }
      } else {
        decls[decl.prop] = decl.value;
      }
    });
    return getColorFromDecls(decls);
  }
  let parts = getClassNameParts(state, className);
  if (!parts) return null;
  const item = dlv(state.classNames.classNames, [...parts, '__info']);
  if (!item.__rule) return null;
  return getColorFromDecls(removeMeta(item));
}
function getColorFromValue(value) {
  if (typeof value !== 'string') return null;
  const trimmedValue = value.trim();
  if (trimmedValue.toLowerCase() === 'transparent') {
    return 'transparent';
  }
  if (trimmedValue.toLowerCase() === 'currentcolor') {
    return 'currentColor';
  }
  if (!/^\s*(?:rgba?|hsla?)\s*\([^)]+\)\s*$/.test(trimmedValue) && !/^\s*#[0-9a-f]+\s*$/i.test(trimmedValue) && !Object.keys(namedColors).includes(trimmedValue)) {
    return null;
  }
  const color = culori.parse(trimmedValue);
  return color != null ? color : null;
}
let toRgb = /*#__PURE__*/culori.converter('rgb');
function culoriColorToVscodeColor(color) {
  var _rgb$alpha;
  let rgb = toRgb(color);
  return {
    red: rgb.r,
    green: rgb.g,
    blue: rgb.b,
    alpha: (_rgb$alpha = rgb.alpha) != null ? _rgb$alpha : 1
  };
}

const htmlLanguages = ['aspnetcorerazor', 'astro', 'astro-markdown', 'blade', 'django-html', 'edge', 'ejs', 'erb', 'gohtml', 'GoHTML', 'gohtmltmpl', 'haml', 'handlebars', 'hbs', 'html', 'HTML (Eex)', 'HTML (EEx)', 'html-eex', 'htmldjango', 'jade', 'leaf', 'liquid', 'markdown', 'mdx', 'mustache', 'njk', 'nunjucks', 'phoenix-heex', 'php', 'razor', 'slim', 'surface', 'twig'];
const cssLanguages = ['css', 'less', 'postcss', 'sass', 'scss', 'stylus', 'sugarss', 'tailwindcss'];
const jsLanguages = ['javascript', 'javascriptreact', 'reason', 'rescript', 'typescript', 'typescriptreact'];

function isJsDoc(state, doc) {
  const userJsLanguages = Object.keys(state.editor.userLanguages).filter(lang => jsLanguages.includes(state.editor.userLanguages[lang]));
  return [...jsLanguages, ...userJsLanguages].indexOf(doc.languageId) !== -1;
}
function isJsxContext(state, doc, position) {
  let str = doc.getText({
    start: {
      line: 0,
      character: 0
    },
    end: position
  });
  let boundaries = getLanguageBoundaries(state, doc, str);
  return boundaries ? boundaries[boundaries.length - 1].type === 'jsx' : false;
}

function isCssDoc(state, doc) {
  const userCssLanguages = Object.keys(state.editor.userLanguages).filter(lang => cssLanguages.includes(state.editor.userLanguages[lang]));
  return [...cssLanguages, ...userCssLanguages].indexOf(doc.languageId) !== -1;
}
function isCssContext(state, doc, position) {
  if (isCssDoc(state, doc)) {
    return true;
  }
  if (isHtmlDoc(state, doc) || isVueDoc(doc) || isSvelteDoc(doc) || isJsDoc(state, doc)) {
    let str = doc.getText({
      start: {
        line: 0,
        character: 0
      },
      end: position
    });
    let boundaries = getLanguageBoundaries(state, doc, str);
    return boundaries ? boundaries[boundaries.length - 1].type === 'css' : false;
  }
  return false;
}

function isWithinRange(position, range) {
  if (position.line === range.start.line && position.character >= range.start.character) {
    if (position.line === range.end.line && position.character > range.end.character) {
      return false;
    } else {
      return true;
    }
  }
  if (position.line === range.end.line && position.character <= range.end.character) {
    if (position.line === range.start.line && position.character < range.end.character) {
      return false;
    } else {
      return true;
    }
  }
  if (position.line > range.start.line && position.line < range.end.line) {
    return true;
  }
  return false;
}

// https://www.codementor.io/@agustinchiappeberrini/lazy-evaluation-and-javascript-a5m7g8gs3
const lazy = getter => {
  let evaluated = false;
  let _res = null;
  const res = function () {
    if (evaluated) return _res;
    _res = getter.apply(this, arguments);
    evaluated = true;
    return _res;
  };
  res.isLazy = true;
  return res;
};

const classAttributeStates = () => ({
  doubleClassList: {
    arb: {
      match: new RegExp('(?<!\\\\)\\['),
      push: 'arbitrary'
    },
    lbrace: {
      match: new RegExp('(?<!\\\\)\\{'),
      push: 'interpBrace'
    },
    rbrace: {
      match: new RegExp('(?<!\\\\)\\}'),
      pop: 1
    },
    end: {
      match: new RegExp('(?<!\\\\)"'),
      pop: 1
    },
    classlist: {
      match: new RegExp('[\\s\\S]'),
      lineBreaks: true
    }
  },
  singleClassList: {
    lbrace: {
      match: new RegExp('(?<!\\\\)\\{'),
      push: 'interpBrace'
    },
    rbrace: {
      match: new RegExp('(?<!\\\\)\\}'),
      pop: 1
    },
    end: {
      match: new RegExp("(?<!\\\\)'"),
      pop: 1
    },
    classlist: {
      match: new RegExp('[\\s\\S]'),
      lineBreaks: true
    }
  },
  tickClassList: {
    lbrace: {
      match: new RegExp('(?<=(?<!\\\\)\\$)\\{'),
      push: 'interpBrace'
    },
    rbrace: {
      match: new RegExp('(?<!\\\\)\\}'),
      pop: 1
    },
    end: {
      match: new RegExp('(?<!\\\\)`'),
      pop: 1
    },
    classlist: {
      match: new RegExp('[\\s\\S]'),
      lineBreaks: true
    }
  },
  interpBrace: {
    startSingle: {
      match: new RegExp("(?<!\\\\)'"),
      push: 'singleClassList'
    },
    startDouble: {
      match: new RegExp('(?<!\\\\)"'),
      push: 'doubleClassList'
    },
    startTick: {
      match: new RegExp('(?<!\\\\)`'),
      push: 'tickClassList'
    },
    lbrace: {
      match: new RegExp('(?<!\\\\)\\{'),
      push: 'interpBrace'
    },
    rbrace: {
      match: new RegExp('(?<!\\\\)\\}'),
      pop: 1
    },
    text: {
      match: new RegExp('[\\s\\S]'),
      lineBreaks: true
    }
  },
  interpSingle: {
    startDouble: {
      match: new RegExp('(?<!\\\\)"'),
      push: 'doubleClassList'
    },
    startTick: {
      match: new RegExp('(?<!\\\\)`'),
      push: 'tickClassList'
    },
    single: {
      match: new RegExp("(?<!\\\\)'"),
      pop: 1
    },
    text: {
      match: new RegExp('[\\s\\S]'),
      lineBreaks: true
    }
  },
  interpDouble: {
    startSingle: {
      match: new RegExp("(?<!\\\\)'"),
      push: 'singleClassList'
    },
    startTick: {
      match: new RegExp('(?<!\\\\)`'),
      push: 'tickClassList'
    },
    double: {
      match: new RegExp('(?<!\\\\)"'),
      pop: 1
    },
    text: {
      match: new RegExp('[\\s\\S]'),
      lineBreaks: true
    }
  },
  arbitrary: {
    arb: {
      match: new RegExp('(?<!\\\\)\\]'),
      pop: 1
    },
    space: {
      match: /\s/,
      pop: 1,
      lineBreaks: true
    },
    arb2: {
      match: new RegExp('[\\s\\S]'),
      lineBreaks: true
    }
  }
});
const simpleClassAttributeStates = {
  main: {
    start: {
      match: '"',
      push: 'doubleClassList'
    }
  },
  doubleClassList: {
    end: {
      match: '"',
      pop: 1
    },
    classlist: {
      match: /[\s\S]/,
      lineBreaks: true
    }
  }
};
const getClassAttributeLexer = /*#__PURE__*/lazy(() => {
  let supportsNegativeLookbehind = true;
  try {
    new RegExp('(?<!)');
  } catch (_) {
    supportsNegativeLookbehind = false;
  }
  if (supportsNegativeLookbehind) {
    return moo.states({
      main: {
        start1: {
          match: '"',
          push: 'doubleClassList'
        },
        start2: {
          match: "'",
          push: 'singleClassList'
        },
        start3: {
          match: '{',
          push: 'interpBrace'
        }
      },
      ...classAttributeStates()
    });
  }
  return moo.states(simpleClassAttributeStates);
});
const getComputedClassAttributeLexer = /*#__PURE__*/lazy(() => {
  let supportsNegativeLookbehind = true;
  try {
    new RegExp('(?<!)');
  } catch (_) {
    supportsNegativeLookbehind = false;
  }
  if (supportsNegativeLookbehind) {
    return moo.states({
      main: {
        lbrace: {
          match: '{',
          push: 'interpBrace'
        },
        single: {
          match: "'",
          push: 'interpSingle'
        },
        double: {
          match: '"',
          push: 'interpDouble'
        }
      },
      ...classAttributeStates()
    });
  }
  return moo.states(simpleClassAttributeStates);
});

function resolveRange(range, relativeTo) {
  return {
    start: {
      line: ((relativeTo == null ? void 0 : relativeTo.start.line) || 0) + range.start.line,
      character: (range.end.line === 0 ? (relativeTo == null ? void 0 : relativeTo.start.character) || 0 : 0) + range.start.character
    },
    end: {
      line: ((relativeTo == null ? void 0 : relativeTo.start.line) || 0) + range.end.line,
      character: (range.end.line === 0 ? (relativeTo == null ? void 0 : relativeTo.start.character) || 0 : 0) + range.end.character
    }
  };
}

function getTextWithoutComments(docOrText, type, range) {
  let text = typeof docOrText === 'string' ? docOrText : docOrText.getText(range);
  if (type === 'js' || type === 'jsx') {
    return getJsWithoutComments(text);
  }
  if (type === 'css') {
    return text.replace(/\/\*.*?\*\//gs, replace);
  }
  return text.replace(/<!--.*?-->/gs, replace);
}
function replace(match) {
  return match.replace(/./gs, char => char === '\n' ? '\n' : ' ');
}
let jsLexer;
function getJsWithoutComments(text) {
  if (!jsLexer) {
    jsLexer = moo.states({
      main: {
        commentLine: /\/\/.*?$/,
        commentBlock: {
          match: /\/\*[^]*?\*\//,
          lineBreaks: true
        },
        stringDouble: /"(?:[^"\\]|\\.)*"/,
        stringSingle: /'(?:[^'\\]|\\.)*'/,
        stringBacktick: /`(?:[^`\\]|\\.)*`/,
        other: {
          match: /[^]/,
          lineBreaks: true
        }
      }
    });
  }
  let str = '';
  jsLexer.reset(text);
  for (let token of jsLexer) {
    if (token.type === 'commentLine') {
      str += ' '.repeat(token.value.length);
    } else if (token.type === 'commentBlock') {
      str += token.value.replace(/./g, ' ');
    } else {
      str += token.value;
    }
  }
  return str;
}

function findAll(re, str) {
  let match;
  let matches = [];
  while ((match = re.exec(str)) !== null) {
    matches.push({
      ...match
    });
  }
  return matches;
}
function findLast(re, str) {
  const matches = findAll(re, str);
  if (matches.length === 0) {
    return null;
  }
  return matches[matches.length - 1];
}
function getClassNamesInClassList(_ref) {
  let {
    classList,
    range,
    important
  } = _ref;
  const parts = classList.split(/(\s+)/);
  const names = [];
  let index = 0;
  for (let i = 0; i < parts.length; i++) {
    if (i % 2 === 0) {
      const start = indexToPosition(classList, index);
      const end = indexToPosition(classList, index + parts[i].length);
      names.push({
        className: parts[i],
        classList: {
          classList,
          range,
          important
        },
        relativeRange: {
          start,
          end
        },
        range: {
          start: {
            line: range.start.line + start.line,
            character: (end.line === 0 ? range.start.character : 0) + start.character
          },
          end: {
            line: range.start.line + end.line,
            character: (end.line === 0 ? range.start.character : 0) + end.character
          }
        }
      });
    }
    index += parts[i].length;
  }
  return names;
}
async function findClassNamesInRange(state, doc, range, mode, includeCustom) {
  if (includeCustom === void 0) {
    includeCustom = true;
  }
  const classLists = await findClassListsInRange(state, doc, range, mode, includeCustom);
  return flatten(classLists.map(getClassNamesInClassList));
}
function findClassListsInCssRange(doc, range) {
  const text = getTextWithoutComments(doc, 'css', range);
  const matches = findAll(/(@apply\s+)(?<classList>[^;}]+?)(?<important>\s*!important)?\s*[;}]/g, text);
  const globalStart = range ? range.start : {
    line: 0,
    character: 0
  };
  return matches.map(match => {
    const start = indexToPosition(text, match.index + match[1].length);
    const end = indexToPosition(text, match.index + match[1].length + match.groups.classList.length);
    return {
      classList: match.groups.classList,
      important: Boolean(match.groups.important),
      range: {
        start: {
          line: globalStart.line + start.line,
          character: (end.line === 0 ? globalStart.character : 0) + start.character
        },
        end: {
          line: globalStart.line + end.line,
          character: (end.line === 0 ? globalStart.character : 0) + end.character
        }
      }
    };
  });
}
async function findCustomClassLists(state, doc, range) {
  const settings = await state.editor.getConfiguration(doc.uri);
  const regexes = settings.tailwindCSS.experimental.classRegex;
  if (!Array.isArray(regexes) || regexes.length === 0) return [];
  const text = doc.getText(range);
  const result = [];
  for (let i = 0; i < regexes.length; i++) {
    try {
      let [containerRegexString, classRegexString] = Array.isArray(regexes[i]) ? regexes[i] : [regexes[i]];
      let containerRegex = new Regex(containerRegexString, 'g');
      let containerMatch;
      while ((containerMatch = containerRegex.exec(text)) !== null) {
        const searchStart = doc.offsetAt((range == null ? void 0 : range.start) || {
          line: 0,
          character: 0
        });
        const matchStart = searchStart + containerMatch.index[1];
        const matchEnd = matchStart + containerMatch[1].length;
        if (classRegexString) {
          let classRegex = new Regex(classRegexString, 'g');
          let classMatch;
          while ((classMatch = classRegex.exec(containerMatch[1])) !== null) {
            const classMatchStart = matchStart + classMatch.index[1];
            const classMatchEnd = classMatchStart + classMatch[1].length;
            result.push({
              classList: classMatch[1],
              range: {
                start: doc.positionAt(classMatchStart),
                end: doc.positionAt(classMatchEnd)
              }
            });
          }
        } else {
          result.push({
            classList: containerMatch[1],
            range: {
              start: doc.positionAt(matchStart),
              end: doc.positionAt(matchEnd)
            }
          });
        }
      }
    } catch (_) {}
  }
  return result;
}
function matchClassAttributes(text, attributes) {
  const attrs = attributes.filter(x => typeof x === 'string').flatMap(a => [a, `\\[${a}\\]`]);
  const re = /(?:\s|:|\()(ATTRS)\s*=\s*['"`{]/;
  return findAll(new RegExp(re.source.replace('ATTRS', attrs.join('|')), 'gi'), text);
}
async function findClassListsInHtmlRange(state, doc, type, range) {
  const text = getTextWithoutComments(doc, type, range);
  const matches = matchClassAttributes(text, (await state.editor.getConfiguration(doc.uri)).tailwindCSS.classAttributes);
  const result = [];
  matches.forEach(match => {
    const subtext = text.substr(match.index + match[0].length - 1);
    let lexer = match[0][0] === ':' || match[1].startsWith('[') && match[1].endsWith(']') ? getComputedClassAttributeLexer() : getClassAttributeLexer();
    lexer.reset(subtext);
    let classLists = [];
    let currentClassList;
    try {
      for (let token of lexer) {
        if (token.type === 'classlist' || token.type.startsWith('arb')) {
          if (currentClassList) {
            currentClassList.value += token.value;
          } else {
            currentClassList = {
              value: token.value,
              offset: token.offset
            };
          }
        } else {
          if (currentClassList) {
            classLists.push({
              value: currentClassList.value,
              offset: currentClassList.offset
            });
          }
          currentClassList = undefined;
        }
      }
    } catch (_) {}
    if (currentClassList) {
      classLists.push({
        value: currentClassList.value,
        offset: currentClassList.offset
      });
    }
    result.push(...classLists.map(_ref2 => {
      let {
        value,
        offset
      } = _ref2;
      if (value.trim() === '') {
        return null;
      }
      const before = value.match(/^\s*/);
      const beforeOffset = before === null ? 0 : before[0].length;
      const after = value.match(/\s*$/);
      const afterOffset = after === null ? 0 : -after[0].length;
      const start = indexToPosition(text, match.index + match[0].length - 1 + offset + beforeOffset);
      const end = indexToPosition(text, match.index + match[0].length - 1 + offset + value.length + afterOffset);
      return {
        classList: value.substr(beforeOffset, value.length + afterOffset),
        range: {
          start: {
            line: ((range == null ? void 0 : range.start.line) || 0) + start.line,
            character: (end.line === 0 ? (range == null ? void 0 : range.start.character) || 0 : 0) + start.character
          },
          end: {
            line: ((range == null ? void 0 : range.start.line) || 0) + end.line,
            character: (end.line === 0 ? (range == null ? void 0 : range.start.character) || 0 : 0) + end.character
          }
        }
      };
    }).filter(x => x !== null));
  });
  return result;
}
async function findClassListsInRange(state, doc, range, mode, includeCustom) {
  if (includeCustom === void 0) {
    includeCustom = true;
  }
  let classLists;
  if (mode === 'css') {
    classLists = findClassListsInCssRange(doc, range);
  } else {
    classLists = await findClassListsInHtmlRange(state, doc, mode, range);
  }
  return dedupeByRange([...classLists, ...(includeCustom ? await findCustomClassLists(state, doc, range) : [])]);
}
async function findClassListsInDocument(state, doc) {
  if (isCssDoc(state, doc)) {
    return findClassListsInCssRange(doc);
  }
  let boundaries = getLanguageBoundaries(state, doc);
  if (!boundaries) return [];
  return dedupeByRange(flatten([...(await Promise.all(boundaries.filter(b => b.type === 'html' || b.type === 'jsx').map(_ref3 => {
    let {
      type,
      range
    } = _ref3;
    return findClassListsInHtmlRange(state, doc, type === 'html' ? 'html' : 'jsx', range);
  }))), ...boundaries.filter(b => b.type === 'css').map(_ref4 => {
    let {
      range
    } = _ref4;
    return findClassListsInCssRange(doc, range);
  }), await findCustomClassLists(state, doc)]));
}
function findHelperFunctionsInDocument(state, doc) {
  if (isCssDoc(state, doc)) {
    return findHelperFunctionsInRange(doc);
  }
  let boundaries = getLanguageBoundaries(state, doc);
  if (!boundaries) return [];
  return flatten(boundaries.filter(b => b.type === 'css').map(_ref5 => {
    let {
      range
    } = _ref5;
    return findHelperFunctionsInRange(doc, range);
  }));
}
function findHelperFunctionsInRange(doc, range) {
  const text = getTextWithoutComments(doc, 'css', range);
  let matches = findAll(/(?<prefix>[\s:;/*(){}])(?<helper>config|theme)(?<innerPrefix>\(\s*)(?<path>[^)]*?)\s*\)/g, text);
  return matches.map(match => {
    let quotesBefore = '';
    let path = match.groups.path.replace(/['"]+$/, '').replace(/^['"]+/, m => {
      quotesBefore = m;
      return '';
    });
    let matches = path.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/);
    if (matches) {
      path = matches[1];
    }
    path = path.replace(/['"]*\s*$/, '');
    let startIndex = match.index + match.groups.prefix.length + match.groups.helper.length + match.groups.innerPrefix.length;
    return {
      helper: match.groups.helper === 'theme' ? 'theme' : 'config',
      path,
      ranges: {
        full: resolveRange({
          start: indexToPosition(text, startIndex),
          end: indexToPosition(text, startIndex + match.groups.path.length)
        }, range),
        path: resolveRange({
          start: indexToPosition(text, startIndex + quotesBefore.length),
          end: indexToPosition(text, startIndex + quotesBefore.length + path.length)
        }, range)
      }
    };
  });
}
function indexToPosition(str, index) {
  const {
    line,
    col
  } = lineColumn(str + '\n', index);
  return {
    line: line - 1,
    character: col - 1
  };
}
async function findClassNameAtPosition(state, doc, position) {
  let classNames = [];
  const positionOffset = doc.offsetAt(position);
  const searchRange = {
    start: doc.positionAt(Math.max(0, positionOffset - 1000)),
    end: doc.positionAt(positionOffset + 1000)
  };
  if (isCssContext(state, doc, position)) {
    classNames = await findClassNamesInRange(state, doc, searchRange, 'css');
  } else if (isHtmlContext(state, doc, position)) {
    classNames = await findClassNamesInRange(state, doc, searchRange, 'html');
  } else if (isJsxContext(state, doc, position)) {
    classNames = await findClassNamesInRange(state, doc, searchRange, 'jsx');
  }
  if (classNames.length === 0) {
    return null;
  }
  const className = classNames.find(_ref6 => {
    let {
      range
    } = _ref6;
    return isWithinRange(position, range);
  });
  if (!className) return null;
  return className;
}

let htmlScriptTypes = [
// https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html#option-1-use-script-tag
'text/html',
// https://vuejs.org/guide/essentials/component-basics.html#dom-template-parsing-caveats
'text/x-template',
// https://github.com/tailwindlabs/tailwindcss-intellisense/issues/722
'text/x-handlebars-template'];
let text = {
  text: {
    match: /[^]/,
    lineBreaks: true
  }
};
let states = {
  main: {
    cssBlockStart: {
      match: /<style(?=[>\s])/,
      push: 'cssBlock'
    },
    jsBlockStart: {
      match: '<script',
      push: 'jsBlock'
    },
    ...text
  },
  cssBlock: {
    styleStart: {
      match: '>',
      next: 'style'
    },
    cssBlockEnd: {
      match: '/>',
      pop: 1
    },
    attrStartDouble: {
      match: '"',
      push: 'attrDouble'
    },
    attrStartSingle: {
      match: "'",
      push: 'attrSingle'
    },
    interp: {
      match: '{',
      push: 'interp'
    },
    ...text
  },
  jsBlock: {
    scriptStart: {
      match: '>',
      next: 'script'
    },
    jsBlockEnd: {
      match: '/>',
      pop: 1
    },
    langAttrStartDouble: {
      match: 'lang="',
      push: 'langAttrDouble'
    },
    langAttrStartSingle: {
      match: "lang='",
      push: 'langAttrSingle'
    },
    typeAttrStartDouble: {
      match: 'type="',
      push: 'typeAttrDouble'
    },
    typeAttrStartSingle: {
      match: "type='",
      push: 'typeAttrSingle'
    },
    attrStartDouble: {
      match: '"',
      push: 'attrDouble'
    },
    attrStartSingle: {
      match: "'",
      push: 'attrSingle'
    },
    interp: {
      match: '{',
      push: 'interp'
    },
    ...text
  },
  interp: {
    interp: {
      match: '{',
      push: 'interp'
    },
    end: {
      match: '}',
      pop: 1
    },
    ...text
  },
  langAttrDouble: {
    langAttrEnd: {
      match: '"',
      pop: 1
    },
    lang: {
      match: /[^"]+/,
      lineBreaks: true
    }
  },
  langAttrSingle: {
    langAttrEnd: {
      match: "'",
      pop: 1
    },
    lang: {
      match: /[^']+/,
      lineBreaks: true
    }
  },
  typeAttrDouble: {
    langAttrEnd: {
      match: '"',
      pop: 1
    },
    type: {
      match: /[^"]+/,
      lineBreaks: true
    }
  },
  typeAttrSingle: {
    langAttrEnd: {
      match: "'",
      pop: 1
    },
    type: {
      match: /[^']+/,
      lineBreaks: true
    }
  },
  attrDouble: {
    attrEnd: {
      match: '"',
      pop: 1
    },
    ...text
  },
  attrSingle: {
    attrEnd: {
      match: "'",
      pop: 1
    },
    ...text
  },
  style: {
    cssBlockEnd: {
      match: '</style>',
      pop: 1
    },
    ...text
  },
  script: {
    jsBlockEnd: {
      match: '</script>',
      pop: 1
    },
    ...text
  }
};
let vueStates = {
  ...states,
  main: {
    htmlBlockStart: {
      match: '<template',
      push: 'htmlBlock'
    },
    ...states.main
  },
  htmlBlock: {
    htmlStart: {
      match: '>',
      next: 'html'
    },
    htmlBlockEnd: {
      match: '/>',
      pop: 1
    },
    attrStartDouble: {
      match: '"',
      push: 'attrDouble'
    },
    attrStartSingle: {
      match: "'",
      push: 'attrSingle'
    },
    interp: {
      match: '{',
      push: 'interp'
    },
    ...text
  },
  html: {
    htmlBlockEnd: {
      match: '</template>',
      pop: 1
    },
    nestedBlockStart: {
      match: '<template',
      push: 'nestedBlock'
    },
    ...text
  },
  nestedBlock: {
    nestedStart: {
      match: '>',
      next: 'nested'
    },
    nestedBlockEnd: {
      match: '/>',
      pop: 1
    },
    ...text
  },
  nested: {
    nestedBlockEnd: {
      match: '</template>',
      pop: 1
    },
    nestedBlockStart: {
      match: '<template',
      push: 'nestedBlock'
    },
    ...text
  }
};
let defaultLexer = /*#__PURE__*/moo.states(states);
let vueLexer = /*#__PURE__*/moo.states(vueStates);
let cache = /*#__PURE__*/new Cache({
  max: 25,
  maxAge: 1000
});
function getLanguageBoundaries(state, doc, text) {
  if (text === void 0) {
    text = doc.getText();
  }
  let cacheKey = `${doc.languageId}:${text}`;
  let cachedBoundaries = cache.get(cacheKey);
  if (cachedBoundaries !== undefined) {
    return cachedBoundaries;
  }
  let isJs = isJsDoc(state, doc);
  let defaultType = isVueDoc(doc) ? 'none' : isHtmlDoc(state, doc) || isSvelteDoc(doc) ? 'html' : isJs ? 'jsx' : null;
  if (defaultType === null) {
    cache.set(cacheKey, null);
    return null;
  }
  text = getTextWithoutComments(text, isJs ? 'js' : 'html');
  let lexer = defaultType === 'none' ? vueLexer : defaultLexer;
  lexer.reset(text);
  let type = defaultType;
  let boundaries = [{
    type: defaultType,
    range: {
      start: {
        line: 0,
        character: 0
      },
      end: undefined
    }
  }];
  let offset = 0;
  try {
    for (let token of lexer) {
      if (!token.type.startsWith('nested')) {
        if (token.type.endsWith('BlockStart')) {
          let position = indexToPosition(text, offset);
          if (!boundaries[boundaries.length - 1].range.end) {
            boundaries[boundaries.length - 1].range.end = position;
          }
          type = token.type.replace(/BlockStart$/, '');
          boundaries.push({
            type,
            range: {
              start: position,
              end: undefined
            }
          });
        } else if (token.type.endsWith('BlockEnd')) {
          let position = indexToPosition(text, offset);
          boundaries[boundaries.length - 1].range.end = position;
          boundaries.push({
            type: defaultType,
            range: {
              start: position,
              end: undefined
            }
          });
        } else if (token.type === 'lang') {
          boundaries[boundaries.length - 1].type = token.text;
        } else if (token.type === 'type' && htmlScriptTypes.includes(token.text)) {
          boundaries[boundaries.length - 1].type = 'html';
        }
      }
      offset += token.text.length;
    }
  } catch {
    cache.set(cacheKey, null);
    return null;
  }
  if (!boundaries[boundaries.length - 1].range.end) {
    boundaries[boundaries.length - 1].range.end = indexToPosition(text, offset);
  }
  cache.set(cacheKey, boundaries);
  return boundaries;
}

function isHtmlDoc(state, doc) {
  const userHtmlLanguages = Object.keys(state.editor.userLanguages).filter(lang => htmlLanguages.includes(state.editor.userLanguages[lang]));
  return [...htmlLanguages, ...userHtmlLanguages].indexOf(doc.languageId) !== -1;
}
function isVueDoc(doc) {
  return doc.languageId === 'vue';
}
function isSvelteDoc(doc) {
  return doc.languageId === 'svelte';
}
function isHtmlContext(state, doc, position) {
  let str = doc.getText({
    start: {
      line: 0,
      character: 0
    },
    end: position
  });
  let boundaries = getLanguageBoundaries(state, doc, str);
  return boundaries ? boundaries[boundaries.length - 1].type === 'html' : false;
}

function stringifyConfigValue(x) {
  if (isObject(x)) return `${Object.keys(x).length} values`;
  if (typeof x === 'function') return 'ƒ';
  return stringifyObject(x, {
    inlineCharacterLimit: Infinity,
    singleQuotes: false,
    transform: (obj, prop, originalResult) => {
      if (typeof obj[prop] === 'function') {
        return 'ƒ';
      }
      return originalResult;
    }
  });
}
function stringifyCss(className, obj, settings) {
  if (obj.__rule !== true && !Array.isArray(obj)) return null;
  if (Array.isArray(obj)) {
    const rules = obj.map(x => stringifyCss(className, x, settings)).filter(Boolean);
    if (rules.length === 0) return null;
    return rules.join('\n\n');
  }
  let css = ``;
  const indent = ' '.repeat(settings.editor.tabSize);
  const context = dlv(obj, '__context', []);
  const props = Object.keys(removeMeta(obj));
  if (props.length === 0) return null;
  for (let i = 0; i < context.length; i++) {
    css += `${indent.repeat(i)}${context[i]} {\n`;
  }
  const indentStr = indent.repeat(context.length);
  const decls = props.reduce((acc, curr, i) => {
    const propStr = ensureArray(obj[curr]).map(val => {
      const px = settings.tailwindCSS.showPixelEquivalents ? remToPx(val, settings.tailwindCSS.rootFontSize) : undefined;
      return `${indentStr + indent}${curr}: ${val}${px ? `/* ${px} */` : ''};`;
    }).join('\n');
    return `${acc}${i === 0 ? '' : '\n'}${propStr}`;
  }, '');
  css += `${indentStr}${augmentClassName(className, obj)} {\n${decls}\n${indentStr}}`;
  for (let i = context.length - 1; i >= 0; i--) {
    css += `${indent.repeat(i)}\n}`;
  }
  return css;
}
function augmentClassName(className, obj) {
  const pseudo = obj.__pseudo.join('');
  const scope = obj.__scope ? `${obj.__scope} ` : '';
  return `${scope}.${escapeClassName(className)}${pseudo}`;
}

function isRawScreen(screen) {
  return isObject(screen) && screen.raw !== undefined;
}
function stringifyScreen(screen) {
  if (!screen) return undefined;
  if (typeof screen === 'string') return `@media (min-width: ${screen})`;
  if (isRawScreen(screen)) {
    return `@media ${screen.raw}`;
  }
  let str = (Array.isArray(screen) ? screen : [screen]).map(range => {
    return [typeof range.min === 'string' ? `(min-width: ${range.min})` : null, typeof range.max === 'string' ? `(max-width: ${range.max})` : null].filter(Boolean).join(' and ');
  }).join(', ');
  return str ? `@media ${str}` : undefined;
}

function isValidLocationForEmmetAbbreviation(document, abbreviationRange) {
  const startAngle = '<';
  const endAngle = '>';
  const escape = '\\';
  const question = '?';
  let start = {
    line: 0,
    character: 0
  };
  let textToBackTrack = document.getText({
    start: {
      line: start.line,
      character: start.character
    },
    end: {
      line: abbreviationRange.start.line,
      character: abbreviationRange.start.character
    }
  });
  // Worse case scenario is when cursor is inside a big chunk of text which needs to backtracked
  // Backtrack only 500 offsets to ensure we dont waste time doing this
  if (textToBackTrack.length > 500) {
    textToBackTrack = textToBackTrack.substr(textToBackTrack.length - 500);
  }
  if (!textToBackTrack.trim()) {
    return true;
  }
  let valid = true;
  let foundSpace = false; // If < is found before finding whitespace, then its valid abbreviation. E.g.: <div|
  let i = textToBackTrack.length - 1;
  if (textToBackTrack[i] === startAngle) {
    return false;
  }
  while (i >= 0) {
    const char = textToBackTrack[i];
    i--;
    if (!foundSpace && /\s/.test(char)) {
      foundSpace = true;
      continue;
    }
    if (char === question && textToBackTrack[i] === startAngle) {
      i--;
      continue;
    }
    // Fix for https://github.com/Microsoft/vscode/issues/55411
    // A space is not a valid character right after < in a tag name.
    if (/\s/.test(char) && textToBackTrack[i] === startAngle) {
      i--;
      continue;
    }
    if (char !== startAngle && char !== endAngle) {
      continue;
    }
    if (i >= 0 && textToBackTrack[i] === escape) {
      i--;
      continue;
    }
    if (char === endAngle) {
      if (i >= 0 && textToBackTrack[i] === '=') {
        continue; // False alarm of cases like =>
      } else {
        break;
      }
    }
    if (char === startAngle) {
      valid = !foundSpace;
      break;
    }
  }
  return valid;
}

function naturalExpand(value, total) {
  let length = typeof total === 'number' ? total.toString().length : 8;
  return ('0'.repeat(length) + value).slice(-length);
}

function gte(v1, v2) {
  if (v1.startsWith('0.0.0-insiders')) {
    return true;
  }
  return semverGte(v1, v2);
}

function docsUrl(version, paths) {
  let major = 0;
  let url = 'https://tailwindcss-v0.netlify.app/docs/';
  if (gte(version, '0.99.0')) {
    major = 1;
    url = 'https://v1.tailwindcss.com/docs/';
  }
  if (gte(version, '1.99.0')) {
    major = 2;
    url = 'https://tailwindcss.com/docs/';
  }
  const path = Array.isArray(paths) ? paths[major] || paths[paths.length - 1] : paths;
  return `${url}${path}`;
}

function getClassNameMeta(state, classNameOrParts) {
  const parts = Array.isArray(classNameOrParts) ? classNameOrParts : getClassNameParts(state, classNameOrParts);
  if (!parts) return null;
  const info = dlv(state.classNames.classNames, [...parts, '__info']);
  if (Array.isArray(info)) {
    return info.map(i => ({
      source: i.__source,
      pseudo: i.__pseudo,
      scope: i.__scope,
      context: i.__context
    }));
  }
  return {
    source: info.__source,
    pseudo: info.__pseudo,
    scope: info.__scope,
    context: info.__context
  };
}

function flagEnabled(state, flag) {
  if (state.featureFlags.future.includes(flag)) {
    return state.config.future === 'all' || dlv(state.config, ['future', flag], false);
  }
  if (state.featureFlags.experimental.includes(flag)) {
    return state.config.experimental === 'all' || dlv(state.config, ['experimental', flag], false);
  }
  return false;
}

function validateApply(state, classNameOrParts) {
  if (state.jit) {
    return {
      isApplyable: true
    };
  }
  const meta = getClassNameMeta(state, classNameOrParts);
  if (!meta) return null;
  if (gte(state.version, '2.0.0-alpha.1') || flagEnabled(state, 'applyComplexClasses')) {
    return {
      isApplyable: true
    };
  }
  const className = Array.isArray(classNameOrParts) ? classNameOrParts.join(state.separator) : classNameOrParts;
  let reason;
  if (Array.isArray(meta)) {
    reason = `'@apply' cannot be used with '${className}' because it is included in multiple rulesets.`;
  } else if (meta.source !== 'utilities') {
    reason = `'@apply' cannot be used with '${className}' because it is not a utility.`;
  } else if (meta.context && meta.context.length > 0) {
    if (meta.context.length === 1) {
      reason = `'@apply' cannot be used with '${className}' because it is nested inside of an at-rule ('${meta.context[0]}').`;
    } else {
      reason = `'@apply' cannot be used with '${className}' because it is nested inside of at-rules (${meta.context.map(c => `'${c}'`).join(', ')}).`;
    }
  } else if (meta.pseudo && meta.pseudo.length > 0) {
    if (meta.pseudo.length === 1) {
      reason = `'@apply' cannot be used with '${className}' because its definition includes a pseudo-selector ('${meta.pseudo[0]}')`;
    } else {
      reason = `'@apply' cannot be used with '${className}' because its definition includes pseudo-selectors (${meta.pseudo.map(p => `'${p}'`).join(', ')}).`;
    }
  }
  if (reason) {
    return {
      isApplyable: false,
      reason
    };
  }
  return {
    isApplyable: true
  };
}

function getVariantsFromClassName(state, className) {
  let allVariants = state.variants.flatMap(variant => {
    if (variant.values.length) {
      return variant.values.map(value => value === 'DEFAULT' ? variant.name : `${variant.name}${variant.hasDash ? '-' : ''}${value}`);
    }
    return [variant.name];
  });
  let variants = new Set();
  let offset = 0;
  let parts = splitAtTopLevelOnly(className, state.separator);
  if (parts.length < 2) {
    return {
      variants: Array.from(variants),
      offset
    };
  }
  parts = parts.filter(Boolean);
  for (let part of parts) {
    if (allVariants.includes(part) || state.jit && (part.includes('[') && part.endsWith(']') || part.includes('/')) && generateRules(state, [`${part}${state.separator}[color:red]`]).rules.length > 0) {
      variants.add(part);
      offset += part.length + state.separator.length;
      continue;
    }
    break;
  }
  return {
    variants: Array.from(variants),
    offset
  };
}
// https://github.com/tailwindlabs/tailwindcss/blob/a8a2e2a7191fbd4bee044523aecbade5823a8664/src/util/splitAtTopLevelOnly.js
function splitAtTopLevelOnly(input, separator) {
  let stack = [];
  let parts = [];
  let lastPos = 0;
  for (let idx = 0; idx < input.length; idx++) {
    let char = input[idx];
    if (stack.length === 0 && char === separator[0]) {
      if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {
        parts.push(input.slice(lastPos, idx));
        lastPos = idx + separator.length;
      }
    }
    if (char === '(' || char === '[' || char === '{') {
      stack.push(char);
    } else if (char === ')' && stack[stack.length - 1] === '(' || char === ']' && stack[stack.length - 1] === '[' || char === '}' && stack[stack.length - 1] === '{') {
      stack.pop();
    }
  }
  parts.push(input.slice(lastPos));
  return parts;
}

let isUtil = className => Array.isArray(className.__info) ? className.__info.some(x => x.__source === 'utilities') : className.__info.__source === 'utilities';
function completionsFromClassList(state, classList, classListRange, filter, context) {
  var _state$completionItem5;
  let classNames = classList.split(/[\s+]/);
  const partialClassName = classNames[classNames.length - 1];
  let sep = state.separator;
  let parts = partialClassName.split(sep);
  let subset;
  let subsetKey = [];
  let isSubset = false;
  let replacementRange = {
    ...classListRange,
    start: {
      ...classListRange.start,
      character: classListRange.end.character - partialClassName.length
    }
  };
  if (state.jit) {
    var _state$completionItem3;
    let {
      variants: existingVariants,
      offset
    } = getVariantsFromClassName(state, partialClassName);
    if (context && (context.triggerKind === 1 || context.triggerKind === 2 && context.triggerCharacter === '/') && partialClassName.includes('/')) {
      // modifiers
      let modifiers;
      let beforeSlash = partialClassName.split('/').slice(0, -1).join('/');
      if (state.classListContainsMetadata) {
        var _state$classList$find, _state$classList$find2;
        let baseClassName = beforeSlash.slice(offset);
        modifiers = (_state$classList$find = state.classList.find(cls => Array.isArray(cls) && cls[0] === baseClassName)) == null ? void 0 : (_state$classList$find2 = _state$classList$find[1]) == null ? void 0 : _state$classList$find2.modifiers;
      } else {
        let testClass = beforeSlash + '/[0]';
        let {
          rules
        } = generateRules(state, [testClass]);
        if (rules.length > 0) {
          let opacities = dlv(state.config, 'theme.opacity', {});
          if (!isObject(opacities)) {
            opacities = {};
          }
          modifiers = Object.keys(opacities);
        }
      }
      if (modifiers) {
        return withDefaults({
          isIncomplete: false,
          items: modifiers.map((modifier, index) => {
            let className = `${beforeSlash}/${modifier}`;
            let kind = 21;
            let documentation;
            const color = getColor(state, className);
            if (color !== null) {
              var _color$alpha;
              kind = 16;
              if (typeof color !== 'string' && ((_color$alpha = color.alpha) != null ? _color$alpha : 1) !== 0) {
                documentation = culori.formatRgb(color);
              }
            }
            return {
              label: className,
              ...(documentation ? {
                documentation
              } : {}),
              kind,
              sortText: naturalExpand(index)
            };
          })
        }, {
          range: replacementRange,
          data: state.completionItemData
        }, state.editor.capabilities.itemDefaults);
      }
    }
    replacementRange.start.character += offset;
    let important = partialClassName.substr(offset).startsWith('!');
    if (important) {
      replacementRange.start.character += 1;
    }
    let items = [];
    if (!important) {
      let variantOrder = 0;
      function variantItem(item) {
        var _state$completionItem;
        return {
          kind: 9,
          data: {
            ...((_state$completionItem = state.completionItemData) != null ? _state$completionItem : {}),
            _type: 'variant'
          },
          command: item.insertTextFormat === 2 // Snippet
          ? undefined : {
            title: '',
            command: 'editor.action.triggerSuggest'
          },
          sortText: '-' + naturalExpand(variantOrder++),
          ...item
        };
      }
      items.push(...state.variants.flatMap(variant => {
        let items = [];
        if (variant.isArbitrary) {
          items.push(variantItem({
            label: `${variant.name}${variant.hasDash ? '-' : ''}[]${sep}`,
            insertTextFormat: 2,
            textEditText: `${variant.name}${variant.hasDash ? '-' : ''}[\${1}]${sep}\${0}`
          }));
        } else if (!existingVariants.includes(variant.name)) {
          let shouldSortVariants = !gte(state.version, '2.99.0');
          let resultingVariants = [...existingVariants, variant.name];
          if (shouldSortVariants) {
            let allVariants = state.variants.map(_ref => {
              let {
                name
              } = _ref;
              return name;
            });
            resultingVariants = resultingVariants.sort((a, b) => allVariants.indexOf(b) - allVariants.indexOf(a));
          }
          items.push(variantItem({
            label: `${variant.name}${sep}`,
            detail: variant.selectors().join(', '),
            textEditText: resultingVariants[resultingVariants.length - 1] + sep,
            additionalTextEdits: shouldSortVariants && resultingVariants.length > 1 ? [{
              newText: resultingVariants.slice(0, resultingVariants.length - 1).join(sep) + sep,
              range: {
                start: {
                  ...classListRange.start,
                  character: classListRange.end.character - partialClassName.length
                },
                end: {
                  ...replacementRange.start,
                  character: replacementRange.start.character
                }
              }
            }] : []
          }));
        }
        if (variant.values.length) {
          items.push(...variant.values.filter(value => !existingVariants.includes(`${variant.name}-${value}`)).map(value => variantItem({
            label: value === 'DEFAULT' ? `${variant.name}${sep}` : `${variant.name}${variant.hasDash ? '-' : ''}${value}${sep}`,
            detail: variant.selectors({
              value
            }).join(', ')
          })));
        }
        return items;
      }));
    }
    if (state.classList) {
      var _state$completionItem2;
      return withDefaults({
        isIncomplete: false,
        items: items.concat(state.classList.map((_ref2, index) => {
          let [className, {
            color
          }] = _ref2;
          let kind = color ? 16 : 21;
          let documentation;
          if (color && typeof color !== 'string') {
            documentation = culori.formatRgb(color);
          }
          return {
            label: className,
            kind,
            ...(documentation ? {
              documentation
            } : {}),
            sortText: naturalExpand(index, state.classList.length)
          };
        }))
      }, {
        data: {
          ...((_state$completionItem2 = state.completionItemData) != null ? _state$completionItem2 : {}),
          ...(important ? {
            important
          } : {}),
          variants: existingVariants
        },
        range: replacementRange
      }, state.editor.capabilities.itemDefaults);
    }
    return withDefaults({
      isIncomplete: false,
      items: items.concat(Object.keys(state.classNames.classNames).filter(className => {
        let item = state.classNames.classNames[className];
        if (existingVariants.length === 0) {
          return item.__info;
        }
        return item.__info && isUtil(item);
      }).map((className, index, classNames) => {
        let kind = 21;
        let documentation;
        const color = getColor(state, className);
        if (color !== null) {
          var _color$alpha2;
          kind = 16;
          if (typeof color !== 'string' && ((_color$alpha2 = color.alpha) != null ? _color$alpha2 : 1) !== 0) {
            documentation = culori.formatRgb(color);
          }
        }
        return {
          label: className,
          kind,
          ...(documentation ? {
            documentation
          } : {}),
          sortText: naturalExpand(index, classNames.length)
        };
      })).filter(item => {
        if (item === null) {
          return false;
        }
        if (filter && !filter(item)) {
          return false;
        }
        return true;
      })
    }, {
      range: replacementRange,
      data: {
        ...((_state$completionItem3 = state.completionItemData) != null ? _state$completionItem3 : {}),
        variants: existingVariants,
        ...(important ? {
          important
        } : {})
      }
    }, state.editor.capabilities.itemDefaults);
  }
  for (let i = parts.length - 1; i > 0; i--) {
    let keys = parts.slice(0, i).filter(Boolean);
    subset = dlv(state.classNames.classNames, keys);
    if (typeof subset !== 'undefined' && typeof dlv(subset, ['__info', '__rule']) === 'undefined') {
      isSubset = true;
      subsetKey = keys;
      replacementRange = {
        ...replacementRange,
        start: {
          ...replacementRange.start,
          character: replacementRange.start.character + keys.join(sep).length + sep.length
        }
      };
      break;
    }
  }
  return withDefaults({
    isIncomplete: false,
    items: Object.keys(isSubset ? subset : state.classNames.classNames).filter(k => k !== '__info').filter(className => isContextItem(state, [...subsetKey, className])).map((className, index, classNames) => {
      var _state$completionItem4;
      return {
        label: className + sep,
        kind: 9,
        command: {
          title: '',
          command: 'editor.action.triggerSuggest'
        },
        sortText: '-' + naturalExpand(index, classNames.length),
        data: {
          ...((_state$completionItem4 = state.completionItemData) != null ? _state$completionItem4 : {}),
          className,
          variants: subsetKey
        }
      };
    }).concat(Object.keys(isSubset ? subset : state.classNames.classNames).filter(className => dlv(state.classNames.classNames, [...subsetKey, className, '__info'])).map((className, index, classNames) => {
      let kind = 21;
      let documentation;
      const color = getColor(state, className);
      if (color !== null) {
        var _color$alpha3;
        kind = 16;
        if (typeof color !== 'string' && ((_color$alpha3 = color.alpha) != null ? _color$alpha3 : 1) !== 0) {
          documentation = culori.formatRgb(color);
        }
      }
      return {
        label: className,
        kind,
        ...(documentation ? {
          documentation
        } : {}),
        sortText: naturalExpand(index, classNames.length)
      };
    })).filter(item => {
      if (item === null) {
        return false;
      }
      if (filter && !filter(item)) {
        return false;
      }
      return true;
    })
  }, {
    range: replacementRange,
    data: {
      ...((_state$completionItem5 = state.completionItemData) != null ? _state$completionItem5 : {}),
      variants: subsetKey
    }
  }, state.editor.capabilities.itemDefaults);
}
async function provideClassAttributeCompletions(state, document, position, context) {
  let str = document.getText({
    start: document.positionAt(Math.max(0, document.offsetAt(position) - 1000)),
    end: position
  });
  let matches = matchClassAttributes(str, (await state.editor.getConfiguration(document.uri)).tailwindCSS.classAttributes);
  if (matches.length === 0) {
    return null;
  }
  let match = matches[matches.length - 1];
  const lexer = match[0][0] === ':' || match[1].startsWith('[') && match[1].endsWith(']') ? getComputedClassAttributeLexer() : getClassAttributeLexer();
  lexer.reset(str.substr(match.index + match[0].length - 1));
  try {
    let tokens = Array.from(lexer);
    let last = tokens[tokens.length - 1];
    if (last.type.startsWith('start') || last.type === 'classlist' || last.type.startsWith('arb')) {
      let classList = '';
      for (let i = tokens.length - 1; i >= 0; i--) {
        if (tokens[i].type === 'classlist' || tokens[i].type.startsWith('arb')) {
          classList = tokens[i].value + classList;
        } else {
          break;
        }
      }
      return completionsFromClassList(state, classList, {
        start: {
          line: position.line,
          character: position.character - classList.length
        },
        end: position
      }, undefined, context);
    }
  } catch (_) {}
  return null;
}
async function provideCustomClassNameCompletions(state, document, position, context) {
  const settings = await state.editor.getConfiguration(document.uri);
  const regexes = settings.tailwindCSS.experimental.classRegex;
  if (regexes.length === 0) return null;
  const positionOffset = document.offsetAt(position);
  const searchRange = {
    start: document.positionAt(Math.max(0, positionOffset - 1000)),
    end: document.positionAt(positionOffset + 1000)
  };
  let str = document.getText(searchRange);
  for (let i = 0; i < regexes.length; i++) {
    try {
      let [containerRegexString, classRegexString] = Array.isArray(regexes[i]) ? regexes[i] : [regexes[i]];
      let containerRegex = new Regex(containerRegexString, 'g');
      let containerMatch;
      while ((containerMatch = containerRegex.exec(str)) !== null) {
        const searchStart = document.offsetAt(searchRange.start);
        const matchStart = searchStart + containerMatch.index[1];
        const matchEnd = matchStart + containerMatch[1].length;
        const cursor = document.offsetAt(position);
        if (cursor >= matchStart && cursor <= matchEnd) {
          let classList;
          if (classRegexString) {
            let classRegex = new Regex(classRegexString, 'g');
            let classMatch;
            while ((classMatch = classRegex.exec(containerMatch[1])) !== null) {
              const classMatchStart = matchStart + classMatch.index[1];
              const classMatchEnd = classMatchStart + classMatch[1].length;
              if (cursor >= classMatchStart && cursor <= classMatchEnd) {
                classList = classMatch[1].substr(0, cursor - classMatchStart);
              }
            }
            if (typeof classList === 'undefined') {
              throw Error();
            }
          } else {
            classList = containerMatch[1].substr(0, cursor - matchStart);
          }
          return completionsFromClassList(state, classList, {
            start: {
              line: position.line,
              character: position.character - classList.length
            },
            end: position
          }, undefined, context);
        }
      }
    } catch (_) {}
  }
  return null;
}
function provideAtApplyCompletions(state, document, position, context) {
  let str = document.getText({
    start: {
      line: Math.max(position.line - 30, 0),
      character: 0
    },
    end: position
  });
  const match = findLast(/@apply\s+(?<classList>[^;}]*)$/gi, str);
  if (match === null) {
    return null;
  }
  const classList = match.groups.classList;
  return completionsFromClassList(state, classList, {
    start: {
      line: position.line,
      character: position.character - classList.length
    },
    end: position
  }, item => {
    var _item$data$variants, _item$data, _item$data$className, _item$data2;
    if (item.kind === 9) {
      return gte(state.version, '2.0.0-alpha.1') || flagEnabled(state, 'applyComplexClasses');
    }
    let variants = (_item$data$variants = (_item$data = item.data) == null ? void 0 : _item$data.variants) != null ? _item$data$variants : [];
    let className = (_item$data$className = (_item$data2 = item.data) == null ? void 0 : _item$data2.className) != null ? _item$data$className : item.label;
    let validated = validateApply(state, [...variants, className]);
    return validated !== null && validated.isApplyable === true;
  }, context);
}
const NUMBER_REGEX = /^(\d+\.?|\d*\.\d+)$/;
function isNumber(str) {
  return NUMBER_REGEX.test(str);
}
async function provideClassNameCompletions(state, document, position, context) {
  if (isCssContext(state, document, position)) {
    return provideAtApplyCompletions(state, document, position, context);
  }
  if (isHtmlContext(state, document, position) || isJsxContext(state, document, position)) {
    return provideClassAttributeCompletions(state, document, position, context);
  }
  return null;
}
function provideCssHelperCompletions(state, document, position) {
  var _state$completionItem6;
  if (!isCssContext(state, document, position)) {
    return null;
  }
  let text = document.getText({
    start: {
      line: position.line,
      character: 0
    },
    // read one extra character so we can see if it's a ] later
    end: {
      line: position.line,
      character: position.character + 1
    }
  });
  const match = text.substr(0, text.length - 1) // don't include that extra character from earlier
  .match(/[\s:;/*(){}](?<helper>config|theme)\(\s*['"]?(?<path>[^)'"]*)$/);
  if (match === null) {
    return null;
  }
  let alpha;
  let path = match.groups.path.replace(/^['"]+/g, '');
  let matches = path.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]*))$/);
  if (matches) {
    path = matches[1];
    alpha = matches[2];
  }
  if (alpha !== undefined) {
    return null;
  }
  let base = match.groups.helper === 'config' ? state.config : dlv(state.config, 'theme', {});
  let parts = path.split(/([\[\].]+)/);
  let keys = parts.filter((_, i) => i % 2 === 0);
  let separators = parts.filter((_, i) => i % 2 !== 0);
  // let obj =
  //   keys.length === 1 ? base : dlv(base, keys.slice(0, keys.length - 1), {})
  // if (!isObject(obj)) return null
  function totalLength(arr) {
    return arr.reduce((acc, cur) => acc + cur.length, 0);
  }
  let obj;
  let offset = keys[keys.length - 1].length;
  let separator = separators.length ? separators[separators.length - 1] : null;
  if (keys.length === 1) {
    obj = base;
  } else {
    for (let i = keys.length - 1; i > 0; i--) {
      let o = dlv(base, keys.slice(0, i));
      if (isObject(o)) {
        obj = o;
        offset = totalLength(parts.slice(i * 2));
        separator = separators[i - 1];
        break;
      }
    }
  }
  if (!obj) return null;
  let editRange = {
    start: {
      line: position.line,
      character: position.character - offset
    },
    end: position
  };
  return withDefaults({
    isIncomplete: false,
    items: Object.keys(obj).sort((a, z) => {
      let aIsNumber = isNumber(a);
      let zIsNumber = isNumber(z);
      if (aIsNumber && !zIsNumber) {
        return -1;
      }
      if (!aIsNumber && zIsNumber) {
        return 1;
      }
      if (aIsNumber && zIsNumber) {
        return parseFloat(a) - parseFloat(z);
      }
      return 0;
    }).map((item, index, items) => {
      var _color$alpha4;
      let color = getColorFromValue(obj[item]);
      const replaceDot = item.indexOf('.') !== -1 && separator && separator.endsWith('.');
      const insertClosingBrace = text.charAt(text.length - 1) !== ']' && (replaceDot || separator && separator.endsWith('['));
      const detail = stringifyConfigValue(obj[item]);
      return {
        label: item,
        sortText: naturalExpand(index, items.length),
        commitCharacters: [!item.includes('.') && '.', !item.includes('[') && '['].filter(Boolean),
        kind: color ? 16 : isObject(obj[item]) ? 9 : 10,
        // VS Code bug causes some values to not display in some cases
        detail: detail === '0' || detail === 'transparent' ? `${detail} ` : detail,
        ...(color && typeof color !== 'string' && ((_color$alpha4 = color.alpha) != null ? _color$alpha4 : 1) !== 0 ? {
          documentation: culori.formatRgb(color)
        } : {}),
        ...(insertClosingBrace ? {
          textEditText: `${item}]`
        } : {}),
        additionalTextEdits: replaceDot ? [{
          newText: '[',
          range: {
            start: {
              ...editRange.start,
              character: editRange.start.character - 1
            },
            end: editRange.start
          }
        }] : []
      };
    })
  }, {
    range: editRange,
    data: {
      ...((_state$completionItem6 = state.completionItemData) != null ? _state$completionItem6 : {}),
      _type: 'helper'
    }
  }, state.editor.capabilities.itemDefaults);
}
function provideTailwindDirectiveCompletions(state, document, position) {
  var _state$completionItem7;
  if (!isCssContext(state, document, position)) {
    return null;
  }
  let text = document.getText({
    start: {
      line: position.line,
      character: 0
    },
    end: position
  });
  const match = text.match(/^\s*@tailwind\s+(?<partial>[^\s]*)$/i);
  if (match === null) return null;
  let items = [gte(state.version, '1.0.0-beta.1') ? {
    label: 'base',
    documentation: {
      kind: 'markdown',
      value: `This injects Tailwind’s base styles and any base styles registered by plugins.\n\n[Tailwind CSS Documentation](${docsUrl(state.version, 'functions-and-directives/#tailwind')})`
    }
  } : {
    label: 'preflight',
    documentation: {
      kind: 'markdown',
      value: `This injects Tailwind’s base styles, which is a combination of Normalize.css and some additional base styles.\n\n[Tailwind CSS Documentation](${docsUrl(state.version, 'functions-and-directives/#tailwind')})`
    }
  }, {
    label: 'components',
    documentation: {
      kind: 'markdown',
      value: `This injects Tailwind’s component classes and any component classes registered by plugins.\n\n[Tailwind CSS Documentation](${docsUrl(state.version, 'functions-and-directives/#tailwind')})`
    }
  }, {
    label: 'utilities',
    documentation: {
      kind: 'markdown',
      value: `This injects Tailwind’s utility classes and any utility classes registered by plugins.\n\n[Tailwind CSS Documentation](${docsUrl(state.version, 'functions-and-directives/#tailwind')})`
    }
  }, state.jit && gte(state.version, '2.1.99') ? {
    label: 'variants',
    documentation: {
      kind: 'markdown',
      value: `Use this directive to control where Tailwind injects the utility variants.\n\nThis directive is considered an advanced escape hatch and it is recommended to omit it whenever possible. If omitted, Tailwind will append these classes to the very end of your stylesheet by default.\n\n[Tailwind CSS Documentation](${docsUrl(state.version, 'just-in-time-mode#variants-are-inserted-at-tailwind-variants')})`
    }
  } : {
    label: 'screens',
    documentation: {
      kind: 'markdown',
      value: `Use this directive to control where Tailwind injects the responsive variations of each utility.\n\nIf omitted, Tailwind will append these classes to the very end of your stylesheet by default.\n\n[Tailwind CSS Documentation](${docsUrl(state.version, 'functions-and-directives/#tailwind')})`
    }
  }];
  return withDefaults({
    isIncomplete: false,
    items: items.map(item => ({
      ...item,
      kind: 21
    }))
  }, {
    data: {
      ...((_state$completionItem7 = state.completionItemData) != null ? _state$completionItem7 : {}),
      _type: '@tailwind'
    },
    range: {
      start: {
        line: position.line,
        character: position.character - match.groups.partial.length
      },
      end: position
    }
  }, state.editor.capabilities.itemDefaults);
}
function provideVariantsDirectiveCompletions(state, document, position) {
  var _state$completionItem8;
  if (!isCssContext(state, document, position)) {
    return null;
  }
  if (gte(state.version, '2.99.0')) {
    return null;
  }
  let text = document.getText({
    start: {
      line: position.line,
      character: 0
    },
    end: position
  });
  const match = text.match(/^\s*@variants\s+(?<partial>[^}]*)$/i);
  if (match === null) return null;
  const parts = match.groups.partial.split(/\s*,\s*/);
  if (/\s+/.test(parts[parts.length - 1])) return null;
  let possibleVariants = state.variants.flatMap(variant => {
    if (variant.values.length) {
      return variant.values.map(value => value === 'DEFAULT' ? variant.name : `${variant.name}${variant.hasDash ? '-' : ''}${value}`);
    }
    return [variant.name];
  });
  const existingVariants = parts.slice(0, parts.length - 1);
  if (state.jit) {
    possibleVariants.unshift('responsive');
    possibleVariants = possibleVariants.filter(v => !state.screens.includes(v));
  }
  return withDefaults({
    isIncomplete: false,
    items: possibleVariants.filter(v => existingVariants.indexOf(v) === -1).map((variant, index, variants) => ({
      // TODO: detail
      label: variant,
      kind: 21,
      sortText: naturalExpand(index, variants.length)
    }))
  }, {
    data: {
      ...((_state$completionItem8 = state.completionItemData) != null ? _state$completionItem8 : {}),
      _type: 'variant'
    },
    range: {
      start: {
        line: position.line,
        character: position.character - parts[parts.length - 1].length
      },
      end: position
    }
  }, state.editor.capabilities.itemDefaults);
}
function provideLayerDirectiveCompletions(state, document, position) {
  var _state$completionItem9;
  if (!isCssContext(state, document, position)) {
    return null;
  }
  let text = document.getText({
    start: {
      line: position.line,
      character: 0
    },
    end: position
  });
  const match = text.match(/^\s*@layer\s+(?<partial>[^\s]*)$/i);
  if (match === null) return null;
  return withDefaults({
    isIncomplete: false,
    items: ['base', 'components', 'utilities'].map((layer, index, layers) => ({
      label: layer,
      kind: 21,
      sortText: naturalExpand(index, layers.length)
    }))
  }, {
    data: {
      ...((_state$completionItem9 = state.completionItemData) != null ? _state$completionItem9 : {}),
      _type: 'layer'
    },
    range: {
      start: {
        line: position.line,
        character: position.character - match.groups.partial.length
      },
      end: position
    }
  }, state.editor.capabilities.itemDefaults);
}
function withDefaults(completionList, defaults, supportedDefaults) {
  let defaultData = supportedDefaults.includes('data');
  let defaultRange = supportedDefaults.includes('editRange');
  return {
    ...completionList,
    ...(defaultData || defaultRange ? {
      itemDefaults: {
        ...(defaultData && defaults.data ? {
          data: defaults.data
        } : {}),
        ...(defaultRange && defaults.range ? {
          editRange: defaults.range
        } : {})
      }
    } : {}),
    items: defaultData && defaultRange ? completionList.items : completionList.items.map(_ref3 => {
      let {
        textEditText,
        ...item
      } = _ref3;
      return {
        ...item,
        ...(defaultData || !defaults.data || item.data ? {} : {
          data: defaults.data
        }),
        ...(defaultRange || !defaults.range ? textEditText ? {
          textEditText
        } : {} : {
          textEdit: {
            newText: textEditText != null ? textEditText : item.label,
            range: defaults.range
          }
        })
      };
    })
  };
}
function provideScreenDirectiveCompletions(state, document, position) {
  var _state$completionItem10;
  if (!isCssContext(state, document, position)) {
    return null;
  }
  let text = document.getText({
    start: {
      line: position.line,
      character: 0
    },
    end: position
  });
  const match = text.match(/^\s*@screen\s+(?<partial>[^\s]*)$/i);
  if (match === null) return null;
  const screens = dlv(state.config, ['screens'], dlv(state.config, ['theme', 'screens'], {}));
  if (!isObject(screens)) return null;
  return withDefaults({
    isIncomplete: false,
    items: Object.keys(screens).map((screen, index) => ({
      label: screen,
      kind: 21,
      sortText: naturalExpand(index)
    }))
  }, {
    data: {
      ...((_state$completionItem10 = state.completionItemData) != null ? _state$completionItem10 : {}),
      _type: 'screen'
    },
    range: {
      start: {
        line: position.line,
        character: position.character - match.groups.partial.length
      },
      end: position
    }
  }, state.editor.capabilities.itemDefaults);
}
function provideCssDirectiveCompletions(state, document, position) {
  var _state$completionItem11;
  if (!isCssContext(state, document, position)) {
    return null;
  }
  let text = document.getText({
    start: {
      line: position.line,
      character: 0
    },
    end: position
  });
  const match = text.match(/^\s*@(?<partial>[a-z]*)$/i);
  if (match === null) return null;
  const items = [{
    label: '@tailwind',
    documentation: {
      kind: 'markdown',
      value: `Use the \`@tailwind\` directive to insert Tailwind’s \`base\`, \`components\`, \`utilities\` and \`${state.jit && gte(state.version, '2.1.99') ? 'variants' : 'screens'}\` styles into your CSS.\n\n[Tailwind CSS Documentation](${docsUrl(state.version, 'functions-and-directives/#tailwind')})`
    }
  }, {
    label: '@screen',
    documentation: {
      kind: 'markdown',
      value: `The \`@screen\` directive allows you to create media queries that reference your breakpoints by name instead of duplicating their values in your own CSS.\n\n[Tailwind CSS Documentation](${docsUrl(state.version, 'functions-and-directives/#screen')})`
    }
  }, {
    label: '@apply',
    documentation: {
      kind: 'markdown',
      value: `Use \`@apply\` to inline any existing utility classes into your own custom CSS.\n\n[Tailwind CSS Documentation](${docsUrl(state.version, 'functions-and-directives/#apply')})`
    }
  }, ...(gte(state.version, '1.8.0') ? [{
    label: '@layer',
    documentation: {
      kind: 'markdown',
      value: `Use the \`@layer\` directive to tell Tailwind which "bucket" a set of custom styles belong to. Valid layers are \`base\`, \`components\`, and \`utilities\`.\n\n[Tailwind CSS Documentation](${docsUrl(state.version, 'functions-and-directives/#layer')})`
    }
  }] : []), ...(gte(state.version, '2.99.0') ? [] : [{
    label: '@variants',
    documentation: {
      kind: 'markdown',
      value: `You can generate \`responsive\`, \`hover\`, \`focus\`, \`active\`, and other variants of your own utilities by wrapping their definitions in the \`@variants\` directive.\n\n[Tailwind CSS Documentation](${docsUrl(state.version, 'functions-and-directives/#variants')})`
    }
  }, {
    label: '@responsive',
    documentation: {
      kind: 'markdown',
      value: `You can generate responsive variants of your own classes by wrapping their definitions in the \`@responsive\` directive.\n\n[Tailwind CSS Documentation](${docsUrl(state.version, 'functions-and-directives/#responsive')})`
    }
  }]), ...(gte(state.version, '3.2.0') ? [{
    label: '@config',
    documentation: {
      kind: 'markdown',
      value: `Use the \`@config\` directive to specify which config file Tailwind should use when compiling that CSS file.\n\n[Tailwind CSS Documentation](${docsUrl(state.version, 'functions-and-directives/#config')})`
    }
  }] : [])];
  return withDefaults({
    isIncomplete: false,
    items: items.map(item => ({
      ...item,
      kind: 14
    }))
  }, {
    data: {
      ...((_state$completionItem11 = state.completionItemData) != null ? _state$completionItem11 : {}),
      _type: 'directive'
    },
    range: {
      start: {
        line: position.line,
        character: position.character - match.groups.partial.length - 1
      },
      end: position
    }
  }, state.editor.capabilities.itemDefaults);
}
async function provideConfigDirectiveCompletions(state, document, position) {
  var _state$completionItem12;
  if (!isCssContext(state, document, position)) {
    return null;
  }
  if (!gte(state.version, '3.2.0')) {
    return null;
  }
  let text = document.getText({
    start: {
      line: position.line,
      character: 0
    },
    end: position
  });
  let match = text.match(/@config\s*(?<partial>'[^']*|"[^"]*)$/);
  if (!match) {
    return null;
  }
  let partial = match.groups.partial.slice(1); // remove quote
  let valueBeforeLastSlash = partial.substring(0, partial.lastIndexOf('/'));
  let valueAfterLastSlash = partial.substring(partial.lastIndexOf('/') + 1);
  return withDefaults({
    isIncomplete: false,
    items: (await state.editor.readDirectory(document, valueBeforeLastSlash || '.')).filter(_ref4 => {
      let [name, type] = _ref4;
      return type.isDirectory || /\.c?js$/.test(name);
    }).map(_ref5 => {
      let [name, type] = _ref5;
      return {
        label: type.isDirectory ? name + '/' : name,
        kind: type.isDirectory ? 19 : 17,
        command: type.isDirectory ? {
          command: 'editor.action.triggerSuggest',
          title: ''
        } : undefined
      };
    })
  }, {
    data: {
      ...((_state$completionItem12 = state.completionItemData) != null ? _state$completionItem12 : {}),
      _type: 'filesystem'
    },
    range: {
      start: {
        line: position.line,
        character: position.character - valueAfterLastSlash.length
      },
      end: position
    }
  }, state.editor.capabilities.itemDefaults);
}
async function provideEmmetCompletions(state, document, position) {
  let settings = await state.editor.getConfiguration(document.uri);
  if (settings.tailwindCSS.emmetCompletions !== true) return null;
  const isHtml = !isJsDoc(state, document) && isHtmlContext(state, document, position);
  const isJs = isJsDoc(state, document) || isJsxContext(state, document, position);
  const syntax = isHtml ? 'html' : isJs ? 'jsx' : null;
  if (syntax === null) {
    return null;
  }
  const extractAbbreviationResults = emmetHelper.extractAbbreviation(document, position, true);
  if (!extractAbbreviationResults || !emmetHelper.isAbbreviationValid(syntax, extractAbbreviationResults.abbreviation)) {
    return null;
  }
  if (!isValidLocationForEmmetAbbreviation(document, extractAbbreviationResults.abbreviationRange)) {
    return null;
  }
  if (isJs) {
    const abbreviation = extractAbbreviationResults.abbreviation;
    if (abbreviation.startsWith('this.')) {
      return null;
    }
    const symbols = await state.editor.getDocumentSymbols(document.uri);
    if (symbols && symbols.find(symbol => abbreviation === symbol.name || abbreviation.startsWith(symbol.name + '.') && !/>|\*|\+/.test(abbreviation))) {
      return null;
    }
  }
  const emmetItems = emmetHelper.doComplete(document, position, syntax, {});
  if (!emmetItems || !emmetItems.items || emmetItems.items.length !== 1) {
    return null;
  }
  // https://github.com/microsoft/vscode/issues/86941
  if (emmetItems.items[0].label === 'widows: ;') {
    return null;
  }
  const parts = emmetItems.items[0].label.split('.');
  if (parts.length < 2) return null;
  return completionsFromClassList(state, parts[parts.length - 1], {
    start: {
      line: position.line,
      character: position.character - parts[parts.length - 1].length
    },
    end: position
  });
}
async function doComplete(state, document, position, context) {
  if (state === null) return {
    items: [],
    isIncomplete: false
  };
  const result = (await provideClassNameCompletions(state, document, position, context)) || provideCssHelperCompletions(state, document, position) || provideCssDirectiveCompletions(state, document, position) || provideScreenDirectiveCompletions(state, document, position) || provideVariantsDirectiveCompletions(state, document, position) || provideTailwindDirectiveCompletions(state, document, position) || provideLayerDirectiveCompletions(state, document, position) || (await provideConfigDirectiveCompletions(state, document, position)) || (await provideCustomClassNameCompletions(state, document, position, context));
  if (result) return result;
  return provideEmmetCompletions(state, document, position);
}
async function resolveCompletionItem(state, item) {
  var _item$data3, _item$data4, _item$data$className2, _item$data5, _item$data6, _item$data$variants2, _item$data7;
  if (['helper', 'directive', 'variant', 'layer', '@tailwind', 'filesystem'].includes((_item$data3 = item.data) == null ? void 0 : _item$data3._type)) {
    return item;
  }
  if (((_item$data4 = item.data) == null ? void 0 : _item$data4._type) === 'screen') {
    let screens = dlv(state.config, ['theme', 'screens'], dlv(state.config, ['screens'], {}));
    if (!isObject(screens)) screens = {};
    item.detail = stringifyScreen(screens[item.label]);
    return item;
  }
  let className = (_item$data$className2 = (_item$data5 = item.data) == null ? void 0 : _item$data5.className) != null ? _item$data$className2 : item.label;
  if ((_item$data6 = item.data) != null && _item$data6.important) {
    className = `!${className}`;
  }
  let variants = (_item$data$variants2 = (_item$data7 = item.data) == null ? void 0 : _item$data7.variants) != null ? _item$data$variants2 : [];
  if (state.jit) {
    if (item.kind === 9) return item;
    if (item.detail && item.documentation) return item;
    let {
      root,
      rules
    } = generateRules(state, [[...variants, className].join(state.separator)]);
    if (rules.length === 0) return item;
    if (!item.detail) {
      if (rules.length === 1) {
        item.detail = await stringifyDecls(state, rules[0]);
      } else {
        item.detail = `${rules.length} rules`;
      }
    }
    if (!item.documentation) {
      item.documentation = {
        kind: 'markdown',
        value: ['```css', await stringifyRoot(state, root), '```'].join('\n')
      };
    }
    return item;
  }
  const rules = dlv(state.classNames.classNames, [...variants, className, '__info']);
  if (item.kind === 9) {
    item.detail = state.classNames.context[className].join(', ');
  } else {
    item.detail = await getCssDetail(state, rules);
    if (!item.documentation) {
      const settings = await state.editor.getConfiguration();
      const css = stringifyCss([...variants, className].join(':'), rules, settings);
      if (css) {
        item.documentation = {
          kind: 'markdown',
          value: ['```css', css, '```'].join('\n')
        };
      }
    }
  }
  return item;
}
function isContextItem(state, keys) {
  const item = dlv(state.classNames.classNames, [keys]);
  if (!isObject(item)) {
    return false;
  }
  if (!state.classNames.context[keys[keys.length - 1]]) {
    return false;
  }
  if (Object.keys(item).filter(x => x !== '__info').length > 0) {
    return true;
  }
  return isObject(item.__info) && !item.__info.__rule;
}
function stringifyDecls$1(obj, settings) {
  let props = Object.keys(obj);
  let nonCustomProps = props.filter(prop => !prop.startsWith('--'));
  if (props.length !== nonCustomProps.length && nonCustomProps.length !== 0) {
    props = nonCustomProps;
  }
  return props.map(prop => ensureArray(obj[prop]).map(value => {
    const px = settings.tailwindCSS.showPixelEquivalents ? remToPx(value, settings.tailwindCSS.rootFontSize) : undefined;
    return `${prop}: ${value}${px ? `/* ${px} */` : ''};`;
  }).join(' ')).join(' ');
}
async function getCssDetail(state, className) {
  if (Array.isArray(className)) {
    return `${className.length} rules`;
  }
  if (className.__rule === true) {
    const settings = await state.editor.getConfiguration();
    return stringifyDecls$1(removeMeta(className), settings);
  }
  return null;
}

(function (DiagnosticKind) {
  DiagnosticKind["CssConflict"] = "cssConflict";
  DiagnosticKind["InvalidApply"] = "invalidApply";
  DiagnosticKind["InvalidScreen"] = "invalidScreen";
  DiagnosticKind["InvalidVariant"] = "invalidVariant";
  DiagnosticKind["InvalidConfigPath"] = "invalidConfigPath";
  DiagnosticKind["InvalidTailwindDirective"] = "invalidTailwindDirective";
  DiagnosticKind["RecommendedVariantOrder"] = "recommendedVariantOrder";
})(exports.DiagnosticKind || (exports.DiagnosticKind = {}));
function isCssConflictDiagnostic(diagnostic) {
  return diagnostic.code === exports.DiagnosticKind.CssConflict;
}
function isInvalidApplyDiagnostic(diagnostic) {
  return diagnostic.code === exports.DiagnosticKind.InvalidApply;
}
function isInvalidScreenDiagnostic(diagnostic) {
  return diagnostic.code === exports.DiagnosticKind.InvalidScreen;
}
function isInvalidVariantDiagnostic(diagnostic) {
  return diagnostic.code === exports.DiagnosticKind.InvalidVariant;
}
function isInvalidConfigPathDiagnostic(diagnostic) {
  return diagnostic.code === exports.DiagnosticKind.InvalidConfigPath;
}
function isInvalidTailwindDirectiveDiagnostic(diagnostic) {
  return diagnostic.code === exports.DiagnosticKind.InvalidTailwindDirective;
}
function isRecommendedVariantOrderDiagnostic(diagnostic) {
  return diagnostic.code === exports.DiagnosticKind.RecommendedVariantOrder;
}

function joinWithAnd(strings) {
  return strings.reduce((acc, cur, i) => {
    if (i === 0) {
      return cur;
    }
    if (strings.length > 1 && i === strings.length - 1) {
      return `${acc} and ${cur}`;
    }
    return `${acc}, ${cur}`;
  }, '');
}

function getClassNameDecls(state, className) {
  const parts = getClassNameParts(state, className);
  if (!parts) return null;
  const info = dlv(state.classNames.classNames, [...parts, '__info']);
  if (Array.isArray(info)) {
    return info.map(removeMeta);
  }
  return removeMeta(info);
}

async function getCssConflictDiagnostics(state, document, settings) {
  let severity = settings.tailwindCSS.lint.cssConflict;
  if (severity === 'ignore') return [];
  let diagnostics = [];
  const classLists = await findClassListsInDocument(state, document);
  classLists.forEach(classList => {
    const classNames = getClassNamesInClassList(classList);
    classNames.forEach((className, index) => {
      if (state.jit) {
        let {
          rules
        } = generateRules(state, [className.className]);
        if (rules.length === 0) {
          return;
        }
        let info = rules.map(rule => {
          let properties = [];
          rule.walkDecls(_ref => {
            let {
              prop
            } = _ref;
            properties.push(prop);
          });
          let context = getRuleContext(state, rule, className.className);
          return {
            context,
            properties
          };
        });
        let otherClassNames = classNames.filter((_className, i) => i !== index);
        let conflictingClassNames = otherClassNames.filter(otherClassName => {
          let {
            rules: otherRules
          } = generateRules(state, [otherClassName.className]);
          if (otherRules.length !== rules.length) {
            return false;
          }
          for (let i = 0; i < otherRules.length; i++) {
            let rule = otherRules[i];
            let properties = [];
            rule.walkDecls(_ref2 => {
              let {
                prop
              } = _ref2;
              properties.push(prop);
            });
            if (!equal(info[i].properties, properties)) {
              return false;
            }
            let context = getRuleContext(state, rule, otherClassName.className);
            if (!equal(info[i].context, context)) {
              return false;
            }
          }
          return true;
        });
        if (conflictingClassNames.length === 0) return;
        diagnostics.push({
          code: exports.DiagnosticKind.CssConflict,
          className,
          otherClassNames: conflictingClassNames,
          range: className.range,
          severity: severity === 'error' ? 1 /* DiagnosticSeverity.Error */ : 2 /* DiagnosticSeverity.Warning */,
          message: `'${className.className}' applies the same CSS properties as ${joinWithAnd(conflictingClassNames.map(conflictingClassName => `'${conflictingClassName.className}'`))}.`,
          relatedInformation: conflictingClassNames.map(conflictingClassName => {
            return {
              message: conflictingClassName.className,
              location: {
                uri: document.uri,
                range: conflictingClassName.range
              }
            };
          })
        });
        return;
      }
      let decls = getClassNameDecls(state, className.className);
      if (!decls) return;
      let properties = Object.keys(decls);
      let meta = getClassNameMeta(state, className.className);
      let otherClassNames = classNames.filter((_className, i) => i !== index);
      let conflictingClassNames = otherClassNames.filter(otherClassName => {
        let otherDecls = getClassNameDecls(state, otherClassName.className);
        if (!otherDecls) return false;
        let otherMeta = getClassNameMeta(state, otherClassName.className);
        return equal(properties, Object.keys(otherDecls)) && !Array.isArray(meta) && !Array.isArray(otherMeta) && equal(meta.context, otherMeta.context) && equal(meta.pseudo, otherMeta.pseudo) && meta.scope === otherMeta.scope;
      });
      if (conflictingClassNames.length === 0) return;
      diagnostics.push({
        code: exports.DiagnosticKind.CssConflict,
        className,
        otherClassNames: conflictingClassNames,
        range: className.range,
        severity: severity === 'error' ? 1 /* DiagnosticSeverity.Error */ : 2 /* DiagnosticSeverity.Warning */,
        message: `'${className.className}' applies the same CSS ${properties.length === 1 ? 'property' : 'properties'} as ${joinWithAnd(conflictingClassNames.map(conflictingClassName => `'${conflictingClassName.className}'`))}.`,
        relatedInformation: conflictingClassNames.map(conflictingClassName => {
          return {
            message: conflictingClassName.className,
            location: {
              uri: document.uri,
              range: conflictingClassName.range
            }
          };
        })
      });
    });
  });
  return diagnostics;
}

async function getInvalidApplyDiagnostics(state, document, settings) {
  let severity = settings.tailwindCSS.lint.invalidApply;
  if (severity === 'ignore') return [];
  const classNames = await findClassNamesInRange(state, document, undefined, 'css', false);
  let diagnostics = classNames.map(className => {
    let result = validateApply(state, className.className);
    if (result === null || result.isApplyable === true) {
      return null;
    }
    return {
      code: exports.DiagnosticKind.InvalidApply,
      severity: severity === 'error' ? 1 /* DiagnosticSeverity.Error */ : 2 /* DiagnosticSeverity.Warning */,
      range: className.range,
      message: result.reason,
      className
    };
  });
  return diagnostics.filter(Boolean);
}

function closest(input, options) {
  return options.concat([]).sort((a, b) => sift(input, a) - sift(input, b))[0];
}

function absoluteRange(range, reference) {
  return {
    start: {
      line: ((reference == null ? void 0 : reference.start.line) || 0) + range.start.line,
      character: (range.end.line === 0 ? (reference == null ? void 0 : reference.start.character) || 0 : 0) + range.start.character
    },
    end: {
      line: ((reference == null ? void 0 : reference.start.line) || 0) + range.end.line,
      character: (range.end.line === 0 ? (reference == null ? void 0 : reference.start.character) || 0 : 0) + range.end.character
    }
  };
}

function getInvalidScreenDiagnostics(state, document, settings) {
  let severity = settings.tailwindCSS.lint.invalidScreen;
  if (severity === 'ignore') return [];
  let diagnostics = [];
  let ranges = [];
  if (isCssDoc(state, document)) {
    ranges.push(undefined);
  } else {
    let boundaries = getLanguageBoundaries(state, document);
    if (!boundaries) return [];
    ranges.push(...boundaries.filter(b => b.type === 'css').map(_ref => {
      let {
        range
      } = _ref;
      return range;
    }));
  }
  ranges.forEach(range => {
    let text = getTextWithoutComments(document, 'css', range);
    let matches = findAll(/(?:\s|^)@screen\s+(?<screen>[^\s{]+)/g, text);
    matches.forEach(match => {
      if (state.screens.includes(match.groups.screen)) {
        return null;
      }
      let message = `The screen '${match.groups.screen}' does not exist in your theme config.`;
      let suggestions = [];
      let suggestion = closest(match.groups.screen, state.screens);
      if (suggestion) {
        suggestions.push(suggestion);
        message += ` Did you mean '${suggestion}'?`;
      }
      diagnostics.push({
        code: exports.DiagnosticKind.InvalidScreen,
        range: absoluteRange({
          start: indexToPosition(text, match.index + match[0].length - match.groups.screen.length),
          end: indexToPosition(text, match.index + match[0].length)
        }, range),
        severity: severity === 'error' ? 1 /* DiagnosticSeverity.Error */ : 2 /* DiagnosticSeverity.Warning */,
        message,
        suggestions
      });
    });
  });
  return diagnostics;
}

function getInvalidVariantDiagnostics(state, document, settings) {
  let severity = settings.tailwindCSS.lint.invalidVariant;
  if (severity === 'ignore') return [];
  if (gte(state.version, '2.99.0')) {
    return [];
  }
  let diagnostics = [];
  let ranges = [];
  if (isCssDoc(state, document)) {
    ranges.push(undefined);
  } else {
    let boundaries = getLanguageBoundaries(state, document);
    if (!boundaries) return [];
    ranges.push(...boundaries.filter(b => b.type === 'css').map(_ref => {
      let {
        range
      } = _ref;
      return range;
    }));
  }
  let possibleVariants = state.variants.flatMap(variant => {
    if (variant.values.length) {
      return variant.values.map(value => value === 'DEFAULT' ? variant.name : `${variant.name}${variant.hasDash ? '-' : ''}${value}`);
    }
    return [variant.name];
  });
  if (state.jit) {
    possibleVariants.unshift('responsive');
    possibleVariants = possibleVariants.filter(v => !state.screens.includes(v));
  }
  ranges.forEach(range => {
    let text = getTextWithoutComments(document, 'css', range);
    let matches = findAll(/(?:\s|^)@variants\s+(?<variants>[^{]+)/g, text);
    matches.forEach(match => {
      let variants = match.groups.variants.split(/(\s*,\s*)/);
      let listStartIndex = match.index + match[0].length - match.groups.variants.length;
      for (let i = 0; i < variants.length; i += 2) {
        let variant = variants[i].trim();
        if (possibleVariants.includes(variant)) {
          continue;
        }
        let message = `The variant '${variant}' does not exist.`;
        let suggestions = [];
        let suggestion = closest(variant, possibleVariants);
        if (suggestion) {
          suggestions.push(suggestion);
          message += ` Did you mean '${suggestion}'?`;
        }
        let variantStartIndex = listStartIndex + variants.slice(0, i).join('').length;
        diagnostics.push({
          code: exports.DiagnosticKind.InvalidVariant,
          range: absoluteRange({
            start: indexToPosition(text, variantStartIndex),
            end: indexToPosition(text, variantStartIndex + variant.length)
          }, range),
          severity: severity === 'error' ? 1 /* DiagnosticSeverity.Error */ : 2 /* DiagnosticSeverity.Warning */,
          message,
          suggestions
        });
      }
    });
  });
  return diagnostics;
}

// https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L6735-L6744
let rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
let reEscapeChar = /\\(\\)?/g;
function stringToPath(string) {
  let result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  // @ts-ignore
  string.replace(rePropName, (match, number, quote, subString) => {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
}

function pathToString(path) {
  if (typeof path === 'string') return path;
  return path.reduce((acc, cur, i) => {
    if (i === 0) return cur;
    if (cur.includes('.')) return `${acc}[${cur}]`;
    return `${acc}.${cur}`;
  }, '');
}
function validateConfigPath(state, path, base) {
  if (base === void 0) {
    base = [];
  }
  let keys = Array.isArray(path) ? path : stringToPath(path);
  let value = dlv(state.config, [...base, ...keys]);
  let suggestions = [];
  function findAlternativePath() {
    let points = combinations('123456789'.substr(0, keys.length - 1)).map(x => x.split('').map(x => parseInt(x, 10)));
    let possibilities = points.map(p => {
      let result = [];
      let i = 0;
      p.forEach(x => {
        result.push(keys.slice(i, x).join('.'));
        i = x;
      });
      result.push(keys.slice(i).join('.'));
      return result;
    }).slice(1); // skip original path
    return possibilities.find(possibility => validateConfigPath(state, possibility, base).isValid);
  }
  if (typeof value === 'undefined') {
    let reason = `'${pathToString(path)}' does not exist in your theme config.`;
    let parentPath = [...base, ...keys.slice(0, keys.length - 1)];
    let parentValue = dlv(state.config, parentPath);
    if (isObject(parentValue)) {
      let closestValidKey = closest(keys[keys.length - 1], Object.keys(parentValue).filter(key => validateConfigPath(state, [...parentPath, key]).isValid));
      if (closestValidKey) {
        suggestions.push(pathToString([...keys.slice(0, keys.length - 1), closestValidKey]));
        reason += ` Did you mean '${suggestions[0]}'?`;
      }
    } else {
      let altPath = findAlternativePath();
      if (altPath) {
        return {
          isValid: false,
          reason: `${reason} Did you mean '${pathToString(altPath)}'?`,
          suggestions: [pathToString(altPath)]
        };
      }
    }
    return {
      isValid: false,
      reason,
      suggestions
    };
  }
  if (!(typeof value === 'string' || typeof value === 'number' || value instanceof String || value instanceof Number || Array.isArray(value) || typeof value === 'function')) {
    let reason = `'${pathToString(path)}' was found but does not resolve to a valid theme value.`;
    if (isObject(value)) {
      let validKeys = Object.keys(value).filter(key => validateConfigPath(state, [...keys, key], base).isValid);
      if (validKeys.length) {
        suggestions.push(...validKeys.map(validKey => pathToString([...keys, validKey])));
        reason += ` Did you mean something like '${suggestions[0]}'?`;
      }
    }
    return {
      isValid: false,
      reason,
      suggestions
    };
  }
  // The value resolves successfully, but we need to check that there
  // wasn't any funny business. If you have a theme object:
  // { msg: 'hello' } and do theme('msg.0')
  // this will resolve to 'h', which is probably not intentional, so we
  // check that all of the keys are object or array keys (i.e. not string
  // indexes)
  let isValid = true;
  for (let i = keys.length - 1; i >= 0; i--) {
    let key = keys[i];
    let parentValue = dlv(state.config, [...base, ...keys.slice(0, i)]);
    if (/^[0-9]+$/.test(key)) {
      if (!isObject(parentValue) && !Array.isArray(parentValue)) {
        isValid = false;
        break;
      }
    } else if (!isObject(parentValue)) {
      isValid = false;
      break;
    }
  }
  if (!isValid) {
    let reason = `'${pathToString(path)}' does not exist in your theme config.`;
    let altPath = findAlternativePath();
    if (altPath) {
      return {
        isValid: false,
        reason: `${reason} Did you mean '${pathToString(altPath)}'?`,
        suggestions: [pathToString(altPath)]
      };
    }
    return {
      isValid: false,
      reason,
      suggestions: []
    };
  }
  return {
    isValid: true,
    value
  };
}
function getInvalidConfigPathDiagnostics(state, document, settings) {
  let severity = settings.tailwindCSS.lint.invalidConfigPath;
  if (severity === 'ignore') return [];
  let diagnostics = [];
  findHelperFunctionsInDocument(state, document).forEach(helperFn => {
    let base = helperFn.helper === 'theme' ? ['theme'] : [];
    let result = validateConfigPath(state, helperFn.path, base);
    if (result.isValid === true) {
      return;
    }
    diagnostics.push({
      code: exports.DiagnosticKind.InvalidConfigPath,
      range: helperFn.ranges.path,
      severity: severity === 'error' ? 1 /* DiagnosticSeverity.Error */ : 2 /* DiagnosticSeverity.Warning */,
      message: result.reason,
      suggestions: result.suggestions
    });
  });
  return diagnostics;
}

function getInvalidTailwindDirectiveDiagnostics(state, document, settings) {
  let severity = settings.tailwindCSS.lint.invalidTailwindDirective;
  if (severity === 'ignore') return [];
  let diagnostics = [];
  let ranges = [];
  if (isCssDoc(state, document)) {
    ranges.push(undefined);
  } else {
    let boundaries = getLanguageBoundaries(state, document);
    if (!boundaries) return [];
    ranges.push(...boundaries.filter(b => b.type === 'css').map(_ref => {
      let {
        range
      } = _ref;
      return range;
    }));
  }
  let notSemicolonLanguages = ['sass', 'sugarss', 'stylus'];
  let regex;
  if (notSemicolonLanguages.includes(document.languageId) || state.editor && notSemicolonLanguages.includes(state.editor.userLanguages[document.languageId])) {
    regex = /(?:\s|^)@tailwind\s+(?<value>[^\r\n]+)/g;
  } else {
    regex = /(?:\s|^)@tailwind\s+(?<value>[^;]+)/g;
  }
  let hasVariantsDirective = state.jit && gte(state.version, '2.1.99');
  ranges.forEach(range => {
    let text = getTextWithoutComments(document, 'css', range);
    let matches = findAll(regex, text);
    let valid = ['utilities', 'components', 'screens', gte(state.version, '1.0.0-beta.1') ? 'base' : 'preflight', hasVariantsDirective && 'variants'].filter(Boolean);
    let suggestable = valid;
    if (hasVariantsDirective) {
      // Don't suggest `screens`, because it's deprecated
      suggestable = suggestable.filter(value => value !== 'screens');
    }
    matches.forEach(match => {
      if (valid.includes(match.groups.value)) {
        return null;
      }
      let message = `'${match.groups.value}' is not a valid value.`;
      let suggestions = [];
      if (match.groups.value === 'preflight') {
        suggestions.push('base');
        message += ` Did you mean 'base'?`;
      } else {
        let suggestion = closest(match.groups.value, suggestable);
        if (suggestion) {
          suggestions.push(suggestion);
          message += ` Did you mean '${suggestion}'?`;
        }
      }
      diagnostics.push({
        code: exports.DiagnosticKind.InvalidTailwindDirective,
        range: absoluteRange({
          start: indexToPosition(text, match.index + match[0].length - match.groups.value.length),
          end: indexToPosition(text, match.index + match[0].length)
        }, range),
        severity: severity === 'error' ? 1 /* DiagnosticSeverity.Error */ : 2 /* DiagnosticSeverity.Warning */,
        message,
        suggestions
      });
    });
  });
  return diagnostics;
}

async function getRecommendedVariantOrderDiagnostics(state, document, settings) {
  if (!state.jit) return [];
  if (gte(state.version, '2.99.0')) return [];
  let severity = settings.tailwindCSS.lint.recommendedVariantOrder;
  if (severity === 'ignore') return [];
  let diagnostics = [];
  const classLists = await findClassListsInDocument(state, document);
  classLists.forEach(classList => {
    const classNames = getClassNamesInClassList(classList);
    classNames.forEach(className => {
      let {
        rules
      } = generateRules(state, [className.className]);
      if (rules.length === 0) {
        return;
      }
      let {
        variants,
        offset
      } = getVariantsFromClassName(state, className.className);
      let sortedVariants = [...variants].sort((a, b) => bigSign(state.jitContext.variantOrder.get(b) - state.jitContext.variantOrder.get(a)));
      if (!equalExact(variants, sortedVariants)) {
        diagnostics.push({
          code: exports.DiagnosticKind.RecommendedVariantOrder,
          suggestions: [[...sortedVariants, className.className.substr(offset)].join(state.separator)],
          range: className.range,
          severity: severity === 'error' ? 1 /* DiagnosticSeverity.Error */ : 2 /* DiagnosticSeverity.Warning */,
          message: 'Variants are not in the recommended order, which may cause unexpected CSS output.'
        });
      }
    });
  });
  return diagnostics;
}

async function doValidate(state, document, only) {
  if (only === void 0) {
    only = [exports.DiagnosticKind.CssConflict, exports.DiagnosticKind.InvalidApply, exports.DiagnosticKind.InvalidScreen, exports.DiagnosticKind.InvalidVariant, exports.DiagnosticKind.InvalidConfigPath, exports.DiagnosticKind.InvalidTailwindDirective, exports.DiagnosticKind.RecommendedVariantOrder];
  }
  const settings = await state.editor.getConfiguration(document.uri);
  return settings.tailwindCSS.validate ? [...(only.includes(exports.DiagnosticKind.CssConflict) ? await getCssConflictDiagnostics(state, document, settings) : []), ...(only.includes(exports.DiagnosticKind.InvalidApply) ? await getInvalidApplyDiagnostics(state, document, settings) : []), ...(only.includes(exports.DiagnosticKind.InvalidScreen) ? getInvalidScreenDiagnostics(state, document, settings) : []), ...(only.includes(exports.DiagnosticKind.InvalidVariant) ? getInvalidVariantDiagnostics(state, document, settings) : []), ...(only.includes(exports.DiagnosticKind.InvalidConfigPath) ? getInvalidConfigPathDiagnostics(state, document, settings) : []), ...(only.includes(exports.DiagnosticKind.InvalidTailwindDirective) ? getInvalidTailwindDirectiveDiagnostics(state, document, settings) : []), ...(only.includes(exports.DiagnosticKind.RecommendedVariantOrder) ? await getRecommendedVariantOrderDiagnostics(state, document, settings) : [])] : [];
}

async function doHover(state, document, position) {
  return (await provideClassNameHover(state, document, position)) || provideCssHelperHover(state, document, position);
}
function provideCssHelperHover(state, document, position) {
  if (!isCssContext(state, document, position)) {
    return null;
  }
  let helperFns = findHelperFunctionsInRange(document, {
    start: {
      line: position.line,
      character: 0
    },
    end: {
      line: position.line + 1,
      character: 0
    }
  });
  for (let helperFn of helperFns) {
    if (isWithinRange(position, helperFn.ranges.path)) {
      let validated = validateConfigPath(state, helperFn.path, helperFn.helper === 'theme' ? ['theme'] : []);
      let value = validated.isValid ? stringifyConfigValue(validated.value) : null;
      if (value === null) {
        return null;
      }
      return {
        contents: {
          kind: 'markdown',
          value: ['```plaintext', value, '```'].join('\n')
        },
        range: helperFn.ranges.path
      };
    }
  }
  return null;
}
async function provideClassNameHover(state, document, position) {
  let className = await findClassNameAtPosition(state, document, position);
  if (className === null) return null;
  if (state.jit) {
    let {
      root,
      rules
    } = generateRules(state, [className.className]);
    if (rules.length === 0) {
      return null;
    }
    return {
      contents: {
        language: 'css',
        value: await stringifyRoot(state, root, document.uri)
      },
      range: className.range
    };
  }
  const parts = getClassNameParts(state, className.className);
  if (!parts) return null;
  if (isCssContext(state, document, position)) {
    let validated = validateApply(state, parts);
    if (validated === null || validated.isApplyable === false) {
      return null;
    }
  }
  const settings = await state.editor.getConfiguration(document.uri);
  const css = stringifyCss(className.className, dlv(state.classNames.classNames, [...parts, '__info']), settings);
  if (!css) return null;
  return {
    contents: {
      language: 'css',
      value: css
    },
    range: className.range
  };
}

function removeRangesFromString(str, rangeOrRanges) {
  let ranges = ensureArray(rangeOrRanges);
  let finder = lineColumn(str + '\n', {
    origin: 0
  });
  let indexRanges = [];
  ranges.forEach(range => {
    let start = finder.toIndex(range.start.line, range.start.character);
    let end = finder.toIndex(range.end.line, range.end.character);
    for (let i = start - 1; i >= 0; i--) {
      if (/\s/.test(str.charAt(i))) {
        start = i;
      } else {
        break;
      }
    }
    indexRanges.push({
      start,
      end
    });
  });
  indexRanges.sort((a, b) => a.start - b.start);
  let result = '';
  let i = 0;
  indexRanges.forEach(indexRange => {
    result += str.substring(i, indexRange.start);
    i = indexRange.end;
  });
  result += str.substring(i);
  return result.trim();
}

async function provideCssConflictCodeActions(_state, params, diagnostic) {
  return [{
    title: `Delete ${joinWithAnd(diagnostic.otherClassNames.map(otherClassName => `'${otherClassName.className}'`))}`,
    kind: 'quickfix',
    diagnostics: [diagnostic],
    edit: {
      changes: {
        [params.textDocument.uri]: [{
          range: diagnostic.className.classList.range,
          newText: removeRangesFromString(diagnostic.className.classList.classList, diagnostic.otherClassNames.map(otherClassName => otherClassName.relativeRange))
        }]
      }
    }
  }];
}

/*
This is a modified version of the postcss-js 'parse' function which accepts the
postcss module as an argument. License below:

The MIT License (MIT)

Copyright 2015 Andrey Sitnik <andrey@sitnik.ru>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var IMPORTANT = /\s*!important\s*$/i;
var unitless = {
  'box-flex': true,
  'box-flex-group': true,
  'column-count': true,
  flex: true,
  'flex-grow': true,
  'flex-positive': true,
  'flex-shrink': true,
  'flex-negative': true,
  'font-weight': true,
  'line-clamp': true,
  'line-height': true,
  opacity: true,
  order: true,
  orphans: true,
  'tab-size': true,
  widows: true,
  'z-index': true,
  zoom: true,
  'fill-opacity': true,
  'stroke-dashoffset': true,
  'stroke-opacity': true,
  'stroke-width': true
};
function dashify(str) {
  return str.replace(/([A-Z])/g, '-$1').replace(/^ms-/, '-ms-').toLowerCase();
}
function decl(parent, name, value, postcss) {
  if (value === false || value === null) return;
  name = dashify(name);
  if (typeof value === 'number') {
    if (value === 0 || unitless[name]) {
      value = value.toString();
    } else {
      value = value.toString() + 'px';
    }
  }
  if (name === 'css-float') name = 'float';
  if (IMPORTANT.test(value)) {
    value = value.replace(IMPORTANT, '');
    parent.push(postcss.decl({
      prop: name,
      value: value,
      important: true
    }));
  } else {
    parent.push(postcss.decl({
      prop: name,
      value: value
    }));
  }
}
function atRule(parent, parts, value, postcss) {
  var node = postcss.atRule({
    name: parts[1],
    params: parts[3] || ''
  });
  if (typeof value === 'object') {
    node.nodes = [];
    parse(value, node, postcss);
  }
  parent.push(node);
}
function parse(obj, parent, postcss) {
  var name, value, node, i;
  for (name in obj) {
    if (obj.hasOwnProperty(name)) {
      value = obj[name];
      if (value === null || typeof value === 'undefined') {
        continue;
      } else if (name[0] === '@') {
        var parts = name.match(/@([^\s]+)(\s+([\w\W]*)\s*)?/);
        if (Array.isArray(value)) {
          for (i = 0; i < value.length; i++) {
            atRule(parent, parts, value[i], postcss);
          }
        } else {
          atRule(parent, parts, value, postcss);
        }
      } else if (Array.isArray(value)) {
        for (i = 0; i < value.length; i++) {
          decl(parent, name, value[i], postcss);
        }
      } else if (typeof value === 'object') {
        node = postcss.rule({
          selector: name
        });
        parse(value, node, postcss);
        parent.push(node);
      } else {
        decl(parent, name, value, postcss);
      }
    }
  }
}
function cssObjToAst(obj, postcss) {
  var root = postcss.root();
  parse(obj, root, postcss);
  return root;
}

async function provideInvalidApplyCodeActions(state, params, diagnostic) {
  let document = state.editor.documents.get(params.textDocument.uri);
  if (!document) return [];
  let documentText = getTextWithoutComments(document, 'css');
  let cssRange;
  let cssText = documentText;
  const {
    postcss
  } = state.modules;
  let changes = [];
  let totalClassNamesInClassList = diagnostic.className.classList.classList.split(/\s+/).length;
  let className = diagnostic.className.className;
  let classNameParts = getClassNameParts(state, className);
  let classNameInfo = dlv(state.classNames.classNames, classNameParts);
  if (Array.isArray(classNameInfo)) {
    return [];
  }
  if (!isCssDoc(state, document)) {
    var _languageBoundaries$f;
    let languageBoundaries = getLanguageBoundaries(state, document);
    if (!languageBoundaries) return [];
    cssRange = (_languageBoundaries$f = languageBoundaries.filter(b => b.type === 'css').find(_ref => {
      let {
        range
      } = _ref;
      return isWithinRange(diagnostic.range.start, range);
    })) == null ? void 0 : _languageBoundaries$f.range;
    if (!cssRange) return [];
    cssText = getTextWithoutComments(document, 'css', cssRange);
  }
  try {
    await postcss.module([
    // TODO: use plain function?
    // @ts-ignore
    postcss.module.plugin('', function (_options) {
      if (_options === void 0) {
        _options = {};
      }
      return root => {
        root.walkRules(rule => {
          if (changes.length) return false;
          rule.walkAtRules('apply', atRule => {
            let atRuleRange = postcssSourceToRange(atRule.source);
            if (cssRange) {
              atRuleRange = absoluteRange(atRuleRange, cssRange);
            }
            if (!isWithinRange(diagnostic.range.start, atRuleRange)) return undefined; // true
            let ast = classNameToAst(state, classNameParts, rule.selector, diagnostic.className.classList.important);
            if (!ast) return false;
            rule.after(ast.nodes);
            let insertedRule = rule.next();
            if (!insertedRule) return false;
            if (totalClassNamesInClassList === 1) {
              atRule.remove();
            } else {
              changes.push({
                range: diagnostic.className.classList.range,
                newText: removeRangesFromString(diagnostic.className.classList.classList, diagnostic.className.relativeRange)
              });
            }
            let ruleRange = postcssSourceToRange(rule.source);
            if (cssRange) {
              ruleRange = absoluteRange(ruleRange, cssRange);
            }
            let outputIndent;
            let documentIndent = detectIndent(cssText);
            changes.push({
              range: ruleRange,
              newText: rule.toString() + (insertedRule.raws.before || '\n\n') + insertedRule.toString().replace(/\n\s*\n/g, '\n').replace(/(@apply [^;\n]+)$/gm, '$1;').replace(/([^\s^]){$/gm, '$1 {').replace(/^\s+/gm, m => {
                if (typeof outputIndent === 'undefined') outputIndent = m;
                return m.replace(new RegExp(outputIndent, 'g'), documentIndent.indent);
              }).replace(/^(\s+)(.*?[^{}]\n)([^\s}])/gm, '$1$2$1$3')
            });
            return false;
          });
          return undefined; // true
        });
      };
    })]).process(cssText, {
      from: undefined
    });
  } catch (_) {
    return [];
  }
  if (!changes.length) {
    return [];
  }
  return [{
    title: 'Extract to new rule',
    kind: 'quickfix',
    diagnostics: [diagnostic],
    edit: {
      changes: {
        [params.textDocument.uri]: changes
      }
    }
  }];
}
function postcssSourceToRange(source) {
  return {
    start: {
      line: source.start.line - 1,
      character: source.start.column - 1
    },
    end: {
      line: source.end.line - 1,
      character: source.end.column
    }
  };
}
function classNameToAst(state, classNameParts, selector, important) {
  if (important === void 0) {
    important = false;
  }
  const baseClassName = classNameParts[classNameParts.length - 1];
  const validatedBaseClassName = validateApply(state, [baseClassName]);
  if (validatedBaseClassName === null || validatedBaseClassName.isApplyable === false) {
    return null;
  }
  const meta = getClassNameMeta(state, classNameParts);
  if (Array.isArray(meta)) return null;
  let context = meta.context;
  let pseudo = meta.pseudo;
  const globalContexts = state.classNames.context;
  const path = [];
  for (let i = 0; i < classNameParts.length - 1; i++) {
    let part = classNameParts[i];
    let common = globalContexts[part];
    if (!common) return null;
    if (state.screens.includes(part)) {
      path.push(`@screen ${part}`);
      context = context.filter(con => !common.includes(con));
    }
  }
  path.push(...context);
  let obj = {};
  for (let i = 1; i <= path.length; i++) {
    dset.dset(obj, path.slice(0, i), {});
  }
  selector = appendPseudosToSelector(selector, pseudo);
  if (selector === null) return null;
  let rule = {
    [selector]: {
      [`@apply ${baseClassName}${important ? ' !important' : ''}`]: ''
    }
  };
  if (path.length) {
    dset.dset(obj, path, rule);
  } else {
    obj = rule;
  }
  return cssObjToAst(obj, state.modules.postcss);
}
function appendPseudosToSelector(selector, pseudos) {
  if (pseudos.length === 0) return selector;
  let canTransform = true;
  let transformedSelector = selectorParser(selectors => {
    flatten(selectors.split(_ => true)).forEach(sel => {
      // @ts-ignore
      for (let i = sel.nodes.length - 1; i >= 0; i--) {
        // @ts-ignore
        if (sel.nodes[i].type !== 'pseudo') {
          break;
          // @ts-ignore
        } else if (pseudos.includes(sel.nodes[i].value)) {
          canTransform = false;
          break;
        }
      }
      if (canTransform) {
        pseudos.forEach(p => {
          // @ts-ignore
          sel.append(selectorParser.pseudo({
            value: p
          }));
        });
      }
    });
  }).processSync(selector);
  if (!canTransform) return null;
  return transformedSelector;
}

function provideSuggestionCodeActions(_state, params, diagnostic) {
  return diagnostic.suggestions.map(suggestion => ({
    title: `Replace with '${suggestion}'`,
    kind: 'quickfix',
    diagnostics: [diagnostic],
    edit: {
      changes: {
        [params.textDocument.uri]: [{
          range: diagnostic.range,
          newText: suggestion
        }]
      }
    }
  }));
}

async function getDiagnosticsFromCodeActionParams(state, params, only) {
  let document = state.editor.documents.get(params.textDocument.uri);
  if (!document) return [];
  let diagnostics = await doValidate(state, document, only);
  return params.context.diagnostics.map(diagnostic => {
    return diagnostics.find(d => {
      return d.code === diagnostic.code && d.message === diagnostic.message && rangesEqual(d.range, diagnostic.range);
    });
  }).filter(Boolean);
}
async function doCodeActions(state, params) {
  if (!state.enabled) {
    return [];
  }
  let diagnostics = await getDiagnosticsFromCodeActionParams(state, params, params.context.diagnostics.map(diagnostic => diagnostic.code).filter(Boolean));
  return Promise.all(diagnostics.map(diagnostic => {
    if (isInvalidApplyDiagnostic(diagnostic)) {
      return provideInvalidApplyCodeActions(state, params, diagnostic);
    }
    if (isCssConflictDiagnostic(diagnostic)) {
      return provideCssConflictCodeActions(state, params, diagnostic);
    }
    if (isInvalidConfigPathDiagnostic(diagnostic) || isInvalidTailwindDirectiveDiagnostic(diagnostic) || isInvalidScreenDiagnostic(diagnostic) || isInvalidVariantDiagnostic(diagnostic) || isRecommendedVariantOrderDiagnostic(diagnostic)) {
      return provideSuggestionCodeActions(state, params, diagnostic);
    }
    return [];
  })).then(flatten).then(x => dedupeBy(x, item => JSON.stringify(item.edit)));
}

async function getDocumentColors(state, document) {
  let colors = [];
  if (!state.enabled) return colors;
  let settings = await state.editor.getConfiguration(document.uri);
  if (settings.tailwindCSS.colorDecorators === false) return colors;
  let classLists = await findClassListsInDocument(state, document);
  classLists.forEach(classList => {
    let classNames = getClassNamesInClassList(classList);
    classNames.forEach(className => {
      var _color$alpha;
      let color = getColor(state, className.className);
      if (color === null || typeof color === 'string' || ((_color$alpha = color.alpha) != null ? _color$alpha : 1) === 0) {
        return;
      }
      colors.push({
        range: className.range,
        color: culoriColorToVscodeColor(color)
      });
    });
  });
  let helperFns = findHelperFunctionsInDocument(state, document);
  helperFns.forEach(fn => {
    var _color$alpha2;
    let keys = stringToPath(fn.path);
    let base = fn.helper === 'theme' ? ['theme'] : [];
    let value = dlv(state.config, [...base, ...keys]);
    let color = getColorFromValue(value);
    if (color && typeof color !== 'string' && ((_color$alpha2 = color.alpha) != null ? _color$alpha2 : 1) !== 0) {
      colors.push({
        range: fn.ranges.path,
        color: culoriColorToVscodeColor(color)
      });
    }
  });
  return dedupeByRange(colors);
}

exports.completionsFromClassList = completionsFromClassList;
exports.culoriColorToVscodeColor = culoriColorToVscodeColor;
exports.doCodeActions = doCodeActions;
exports.doComplete = doComplete;
exports.doHover = doHover;
exports.doValidate = doValidate;
exports.getColor = getColor;
exports.getColorFromValue = getColorFromValue;
exports.getDocumentColors = getDocumentColors;
exports.isCssConflictDiagnostic = isCssConflictDiagnostic;
exports.isInvalidApplyDiagnostic = isInvalidApplyDiagnostic;
exports.isInvalidConfigPathDiagnostic = isInvalidConfigPathDiagnostic;
exports.isInvalidScreenDiagnostic = isInvalidScreenDiagnostic;
exports.isInvalidTailwindDirectiveDiagnostic = isInvalidTailwindDirectiveDiagnostic;
exports.isInvalidVariantDiagnostic = isInvalidVariantDiagnostic;
exports.isRecommendedVariantOrderDiagnostic = isRecommendedVariantOrderDiagnostic;
exports.resolveCompletionItem = resolveCompletionItem;
//# sourceMappingURL=tailwindcss-language-service.cjs.development.js.map
