{"version":3,"file":"tailwindcss-language-service.cjs.production.min.js","sources":["../src/util/isObject.ts","../src/util/removeMeta.ts","../src/util/rangesEqual.ts","../src/util/array.ts","../src/util/combinations.ts","../src/util/getClassNameAtPosition.ts","../src/util/remToPx.ts","../src/util/jit.ts","../src/util/color.ts","../src/util/languages.ts","../src/util/js.ts","../src/util/css.ts","../src/util/isWithinRange.ts","../src/util/lazy.ts","../src/util/lexers.ts","../src/util/resolveRange.ts","../src/util/doc.ts","../src/util/find.ts","../src/util/getLanguageBoundaries.ts","../src/util/html.ts","../src/util/stringify.ts","../src/util/naturalExpand.ts","../src/util/semver.ts","../src/util/docsUrl.ts","../src/util/getClassNameMeta.ts","../src/util/flagEnabled.ts","../src/util/validateApply.ts","../src/util/getVariantsFromClassName.ts","../src/completionProvider.ts","../src/diagnostics/types.ts","../src/util/joinWithAnd.ts","../src/util/getClassNameDecls.ts","../src/diagnostics/getCssConflictDiagnostics.ts","../src/diagnostics/getInvalidApplyDiagnostics.ts","../src/util/closest.ts","../src/util/absoluteRange.ts","../src/diagnostics/getInvalidScreenDiagnostics.ts","../src/diagnostics/getInvalidVariantDiagnostics.ts","../src/util/stringToPath.ts","../src/diagnostics/getInvalidConfigPathDiagnostics.ts","../src/diagnostics/getInvalidTailwindDirectiveDiagnostics.ts","../src/diagnostics/getRecommendedVariantOrderDiagnostics.ts","../src/diagnostics/diagnosticsProvider.ts","../src/util/removeRangesFromString.ts","../src/util/cssObjToAst.ts","../src/codeActions/provideInvalidApplyCodeActions.ts","../src/codeActions/codeActionProvider.ts","../src/codeActions/provideCssConflictCodeActions.ts","../src/codeActions/provideSuggestionCodeActions.ts","../src/util/isValidLocationForEmmetAbbreviation.ts","../src/hoverProvider.ts","../src/documentColorProvider.ts","../src/util/screens.ts"],"sourcesContent":["export default function isObject(variable: any): boolean {\n  return Object.prototype.toString.call(variable) === '[object Object]'\n}\n","import isObject from './isObject'\n\nexport default function removeMeta(obj: any): any {\n  let result = {}\n  for (let key in obj) {\n    if (key.substr(0, 2) === '__') continue\n    if (isObject(obj[key])) {\n      result[key] = removeMeta(obj[key])\n    } else {\n      result[key] = obj[key]\n    }\n  }\n  return result\n}\n","import type { Range } from 'vscode-languageserver'\n\nexport function rangesEqual(a: Range, b: Range): boolean {\n  return (\n    a.start.line === b.start.line &&\n    a.start.character === b.start.character &&\n    a.end.line === b.end.line &&\n    a.end.character === b.end.character\n  )\n}\n","import type { Range } from 'vscode-languageserver'\nimport { rangesEqual } from './rangesEqual'\n\nexport function dedupe<T>(arr: Array<T>): Array<T> {\n  return arr.filter((value, index, self) => self.indexOf(value) === index)\n}\n\nexport function dedupeBy<T>(arr: Array<T>, transform: (item: T) => any): Array<T> {\n  return arr.filter((value, index, self) => self.map(transform).indexOf(transform(value)) === index)\n}\n\nexport function dedupeByRange<T extends { range: Range }>(arr: Array<T>): Array<T> {\n  return arr.filter(\n    (classList, classListIndex) =>\n      classListIndex === arr.findIndex((c) => rangesEqual(c.range, classList.range))\n  )\n}\n\nexport function ensureArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value]\n}\n\nexport function flatten<T>(arrays: T[][]): T[] {\n  return [].concat.apply([], arrays)\n}\n\nexport function equal(a: any[], b: any[]): boolean {\n  if (a === b) return true\n  if (a.length !== b.length) return false\n\n  let aSorted = a.concat().sort()\n  let bSorted = b.concat().sort()\n\n  for (let i = 0; i < aSorted.length; ++i) {\n    if (aSorted[i] !== bSorted[i]) return false\n  }\n\n  return true\n}\n\nexport function equalExact(a: any[], b: any[]): boolean {\n  if (a === b) return true\n  if (a.length !== b.length) return false\n\n  for (let i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) return false\n  }\n\n  return true\n}\n","export function combinations(str: string): string[] {\n  let fn = function (active: string, rest: string, a: string[]) {\n    if (!active && !rest) return undefined\n    if (!rest) {\n      a.push(active)\n    } else {\n      fn(active + rest[0], rest.slice(1), a)\n      fn(active, rest.slice(1), a)\n    }\n    return a\n  }\n  return fn('', str, [])\n}\n","import { State } from './state'\nimport { combinations } from './combinations'\nimport dlv from 'dlv'\n\nexport function getClassNameParts(state: State, className: string): string[] {\n  let separator = state.separator\n  className = className.replace(/^\\./, '')\n  let parts: string[] = className.split(separator)\n\n  if (parts.length === 1) {\n    return dlv(state.classNames.classNames, [className, '__info', '__rule']) ===\n      true ||\n      Array.isArray(dlv(state.classNames.classNames, [className, '__info']))\n      ? [className]\n      : null\n  }\n\n  let points = combinations('123456789'.substr(0, parts.length - 1)).map((x) =>\n    x.split('').map((x) => parseInt(x, 10))\n  )\n\n  let possibilities: string[][] = [\n    [className],\n    ...points.map((p) => {\n      let result = []\n      let i = 0\n      p.forEach((x) => {\n        result.push(parts.slice(i, x).join('-'))\n        i = x\n      })\n      result.push(parts.slice(i).join('-'))\n      return result\n    }),\n  ]\n\n  return possibilities.find((key) => {\n    if (\n      dlv(state.classNames.classNames, [...key, '__info', '__rule']) === true ||\n      Array.isArray(dlv(state.classNames.classNames, [...key, '__info']))\n    ) {\n      return true\n    }\n    return false\n  })\n}\n","export function remToPx(value: string, rootSize: number = 16): string | undefined {\n  if (/^-?[0-9.]+rem$/.test(value)) {\n    let number = parseFloat(value.substr(0, value.length - 3))\n    if (!isNaN(number)) {\n      return `${number * rootSize}px`\n    }\n  }\n  return undefined\n}\n","import { State } from './state'\nimport type { Container, Document, Root, Rule } from 'postcss'\nimport dlv from 'dlv'\nimport { remToPx } from './remToPx'\n\nexport function bigSign(bigIntValue) {\n  // @ts-ignore\n  return (bigIntValue > 0n) - (bigIntValue < 0n)\n}\n\nexport function generateRules(state: State, classNames: string[]): { root: Root; rules: Rule[] } {\n  let rules: [bigint, Rule][] = state.modules.jit.generateRules\n    .module(new Set(classNames), state.jitContext)\n    .sort(([a], [z]) => bigSign(a - z))\n\n  let root = state.modules.postcss.module.root({ nodes: rules.map(([, rule]) => rule) })\n  state.modules.jit.expandApplyAtRules.module(state.jitContext)(root)\n\n  let actualRules: Rule[] = []\n  root.walkRules((subRule) => {\n    actualRules.push(subRule)\n  })\n\n  return {\n    root,\n    rules: actualRules,\n  }\n}\n\nexport async function stringifyRoot(state: State, root: Root, uri?: string): Promise<string> {\n  let settings = await state.editor.getConfiguration(uri)\n  let clone = root.clone()\n\n  clone.walkAtRules('defaults', (node) => {\n    node.remove()\n  })\n\n  if (settings.tailwindCSS.showPixelEquivalents) {\n    clone.walkDecls((decl) => {\n      let px = remToPx(decl.value, settings.tailwindCSS.rootFontSize)\n      if (px) {\n        decl.value = `${decl.value}/* ${px} */`\n      }\n    })\n  }\n\n  return clone\n    .toString()\n    .replace(/([^;{}\\s])(\\n\\s*})/g, (_match, before, after) => `${before};${after}`)\n    .replace(/^(?:    )+/gm, (indent: string) =>\n      ' '.repeat((indent.length / 4) * settings.editor.tabSize)\n    )\n}\n\nexport function stringifyRules(state: State, rules: Rule[], tabSize: number = 2): string {\n  return rules\n    .map((rule) => rule.toString().replace(/([^}{;])$/gm, '$1;'))\n    .join('\\n\\n')\n    .replace(/^(?:    )+/gm, (indent: string) => ' '.repeat((indent.length / 4) * tabSize))\n}\n\nexport async function stringifyDecls(state: State, rule: Rule, uri?: string): Promise<string> {\n  let settings = await state.editor.getConfiguration(uri)\n\n  let result = []\n  rule.walkDecls(({ prop, value }) => {\n    let px = settings.tailwindCSS.showPixelEquivalents\n      ? remToPx(value, settings.tailwindCSS.rootFontSize)\n      : undefined\n    result.push(`${prop}: ${value}${px ? `/* ${px} */` : ''};`)\n  })\n  return result.join(' ')\n}\n\nfunction replaceClassName(state: State, selector: string, find: string, replace: string): string {\n  const transform = (selectors) => {\n    selectors.walkClasses((className) => {\n      if (className.value === find) {\n        className.value = replace\n      }\n    })\n  }\n\n  return state.modules.postcssSelectorParser.module(transform).processSync(selector)\n}\n\nexport function getRuleContext(state: State, rule: Rule, className: string): string[] {\n  let context: string[] = [replaceClassName(state, rule.selector, className, '__placeholder__')]\n\n  let p: Container | Document = rule\n  while (p.parent && p.parent.type !== 'root') {\n    p = p.parent\n    if (p.type === 'atrule') {\n      // @ts-ignore\n      context.unshift(`@${p.name} ${p.params}`)\n    }\n  }\n\n  return context\n}\n","import dlv from 'dlv'\nimport { State } from './state'\nimport removeMeta from './removeMeta'\nimport { ensureArray, dedupe, flatten } from './array'\nimport type { Color } from 'vscode-languageserver'\nimport { getClassNameParts } from './getClassNameAtPosition'\nimport * as jit from './jit'\nimport * as culori from 'culori'\nimport namedColors from 'color-name'\n\nconst COLOR_PROPS = [\n  'accent-color',\n  'caret-color',\n  'color',\n  'column-rule-color',\n  'background-color',\n  'border-color',\n  'border-top-color',\n  'border-right-color',\n  'border-bottom-color',\n  'border-left-color',\n  'fill',\n  'outline-color',\n  'stop-color',\n  'stroke',\n  'text-decoration-color',\n]\n\nexport type KeywordColor = 'transparent' | 'currentColor'\n\nfunction getKeywordColor(value: unknown): KeywordColor | null {\n  if (typeof value !== 'string') return null\n  let lowercased = value.toLowerCase()\n  if (lowercased === 'transparent') {\n    return 'transparent'\n  }\n  if (lowercased === 'currentcolor') {\n    return 'currentColor'\n  }\n  return null\n}\n\n// https://github.com/khalilgharbaoui/coloregex\nconst colorRegex = new RegExp(\n  `(?:^|\\\\s|\\\\(|,)(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\\\\(\\\\s*(-?[\\\\d.]+%?(\\\\s*[,/]\\\\s*|\\\\s+)+){2,3}\\\\s*([\\\\d.]+%?|var\\\\([^)]+\\\\))?\\\\)|transparent|currentColor|${Object.keys(\n    namedColors\n  ).join('|')})(?:$|\\\\s|\\\\)|,)`,\n  'gi'\n)\n\nfunction replaceColorVarsWithTheirDefaults(str: string): string {\n  // rgb(var(--primary, 66 66 66))\n  // -> rgb(66 66 66)\n  return str.replace(/((?:rgb|hsl)a?\\(\\s*)var\\([^,]+,\\s*([^)]+)\\)/gi, '$1$2')\n}\n\nfunction getColorsInString(str: string): (culori.Color | KeywordColor)[] {\n  if (/(?:box|drop)-shadow/.test(str)) return []\n\n  return Array.from(replaceColorVarsWithTheirDefaults(str).matchAll(colorRegex), (match) => {\n    let color = match[1].replace(/var\\([^)]+\\)/, '1')\n    return getKeywordColor(color) ?? culori.parse(color)\n  }).filter(Boolean)\n}\n\nfunction getColorFromDecls(\n  decls: Record<string, string | string[]>\n): culori.Color | KeywordColor | null {\n  let props = Object.keys(decls).filter((prop) => {\n    // ignore content: \"\";\n    if (\n      prop === 'content' &&\n      (decls[prop] === '\"\"' || decls[prop] === \"''\" || decls[prop] === 'var(--tw-content)')\n    ) {\n      return false\n    }\n    return true\n  })\n\n  if (props.length === 0) return null\n\n  const nonCustomProps = props.filter((prop) => !prop.startsWith('--'))\n\n  const areAllCustom = nonCustomProps.length === 0\n\n  if (!areAllCustom && nonCustomProps.some((prop) => !COLOR_PROPS.includes(prop))) {\n    // they should all be color-based props\n    return null\n  }\n\n  const propsToCheck = areAllCustom ? props : nonCustomProps\n\n  const colors = propsToCheck.flatMap((prop) => ensureArray(decls[prop]).flatMap(getColorsInString))\n\n  // check that all of the values are valid colors\n  // if (colors.some((color) => color instanceof TinyColor && !color.isValid)) {\n  //   return null\n  // }\n\n  // check that all of the values are the same color, ignoring alpha\n  const colorStrings = dedupe(\n    colors.map((color) =>\n      typeof color === 'string' ? color : culori.formatRgb({ ...color, alpha: undefined })\n    )\n  )\n  if (colorStrings.length !== 1) {\n    return null\n  }\n\n  let keyword = getKeywordColor(colorStrings[0])\n  if (keyword) {\n    return keyword\n  }\n\n  const nonKeywordColors = colors.filter(\n    (color): color is culori.Color => typeof color !== 'string'\n  )\n\n  const alphas = dedupe(nonKeywordColors.map((color) => color.alpha ?? 1))\n\n  if (alphas.length === 1) {\n    return nonKeywordColors[0]\n  }\n\n  if (alphas.length === 2 && alphas.includes(0)) {\n    return nonKeywordColors.find((color) => (color.alpha ?? 1) !== 0)\n  }\n\n  return null\n}\n\nexport function getColor(state: State, className: string): culori.Color | KeywordColor | null {\n  if (state.jit) {\n    if (state.classNames) {\n      const item = dlv(state.classNames.classNames, [className, '__info'])\n      if (item && item.__rule) {\n        return getColorFromDecls(removeMeta(item))\n      }\n    }\n\n    let { root, rules } = jit.generateRules(state, [className])\n    if (rules.length === 0) return null\n\n    let decls: Record<string, string | string[]> = {}\n    root.walkDecls((decl) => {\n      let value = decls[decl.prop]\n      if (value) {\n        if (Array.isArray(value)) {\n          value.push(decl.value)\n        } else {\n          decls[decl.prop] = [value, decl.value]\n        }\n      } else {\n        decls[decl.prop] = decl.value\n      }\n    })\n    return getColorFromDecls(decls)\n  }\n\n  let parts = getClassNameParts(state, className)\n  if (!parts) return null\n\n  const item = dlv(state.classNames.classNames, [...parts, '__info'])\n  if (!item.__rule) return null\n\n  return getColorFromDecls(removeMeta(item))\n}\n\nexport function getColorFromValue(value: unknown): culori.Color | KeywordColor | null {\n  if (typeof value !== 'string') return null\n  const trimmedValue = value.trim()\n  if (trimmedValue.toLowerCase() === 'transparent') {\n    return 'transparent'\n  }\n  if (trimmedValue.toLowerCase() === 'currentcolor') {\n    return 'currentColor'\n  }\n  if (\n    !/^\\s*(?:rgba?|hsla?)\\s*\\([^)]+\\)\\s*$/.test(trimmedValue) &&\n    !/^\\s*#[0-9a-f]+\\s*$/i.test(trimmedValue) &&\n    !Object.keys(namedColors).includes(trimmedValue)\n  ) {\n    return null\n  }\n  const color = culori.parse(trimmedValue)\n  return color ?? null\n}\n\nlet toRgb = culori.converter('rgb')\n\nexport function culoriColorToVscodeColor(color: culori.Color): Color {\n  let rgb = toRgb(color)\n  return { red: rgb.r, green: rgb.g, blue: rgb.b, alpha: rgb.alpha ?? 1 }\n}\n","export const htmlLanguages = [\n  'aspnetcorerazor',\n  'astro',\n  'astro-markdown',\n  'blade',\n  'django-html',\n  'edge',\n  'ejs',\n  'erb',\n  'gohtml',\n  'GoHTML',\n  'gohtmltmpl',\n  'haml',\n  'handlebars',\n  'hbs',\n  'html',\n  'HTML (Eex)',\n  'HTML (EEx)',\n  'html-eex',\n  'htmldjango',\n  'jade',\n  'leaf',\n  'liquid',\n  'markdown',\n  'mdx',\n  'mustache',\n  'njk',\n  'nunjucks',\n  'phoenix-heex',\n  'php',\n  'razor',\n  'slim',\n  'surface',\n  'twig',\n]\n\nexport const cssLanguages = [\n  'css',\n  'less',\n  'postcss',\n  'sass',\n  'scss',\n  'stylus',\n  'sugarss',\n  'tailwindcss',\n]\n\nexport const jsLanguages = [\n  'javascript',\n  'javascriptreact',\n  'reason',\n  'rescript',\n  'typescript',\n  'typescriptreact',\n]\n\nexport const specialLanguages = ['vue', 'svelte']\n\nexport const languages = [...cssLanguages, ...htmlLanguages, ...jsLanguages, ...specialLanguages]\n","import type { TextDocument, Position } from 'vscode-languageserver'\nimport { State } from './state'\nimport { jsLanguages } from './languages'\nimport { getLanguageBoundaries } from './getLanguageBoundaries'\n\nexport function isJsDoc(state: State, doc: TextDocument): boolean {\n  const userJsLanguages = Object.keys(state.editor.userLanguages).filter((lang) =>\n    jsLanguages.includes(state.editor.userLanguages[lang])\n  )\n\n  return [...jsLanguages, ...userJsLanguages].indexOf(doc.languageId) !== -1\n}\n\nexport function isJsxContext(state: State, doc: TextDocument, position: Position): boolean {\n  let str = doc.getText({\n    start: { line: 0, character: 0 },\n    end: position,\n  })\n\n  let boundaries = getLanguageBoundaries(state, doc, str)\n\n  return boundaries ? boundaries[boundaries.length - 1].type === 'jsx' : false\n}\n","import type { TextDocument, Position } from 'vscode-languageserver'\nimport { isVueDoc, isSvelteDoc, isHtmlDoc } from './html'\nimport { isJsDoc } from './js'\nimport { State } from './state'\nimport { cssLanguages } from './languages'\nimport { getLanguageBoundaries } from './getLanguageBoundaries'\n\nexport function isCssDoc(state: State, doc: TextDocument): boolean {\n  const userCssLanguages = Object.keys(state.editor.userLanguages).filter((lang) =>\n    cssLanguages.includes(state.editor.userLanguages[lang])\n  )\n\n  return [...cssLanguages, ...userCssLanguages].indexOf(doc.languageId) !== -1\n}\n\nexport function isCssContext(state: State, doc: TextDocument, position: Position): boolean {\n  if (isCssDoc(state, doc)) {\n    return true\n  }\n\n  if (isHtmlDoc(state, doc) || isVueDoc(doc) || isSvelteDoc(doc) || isJsDoc(state, doc)) {\n    let str = doc.getText({\n      start: { line: 0, character: 0 },\n      end: position,\n    })\n\n    let boundaries = getLanguageBoundaries(state, doc, str)\n\n    return boundaries ? boundaries[boundaries.length - 1].type === 'css' : false\n  }\n\n  return false\n}\n","import type { Position, Range } from 'vscode-languageserver'\n\nexport function isWithinRange(position: Position, range: Range): boolean {\n  if (\n    position.line === range.start.line &&\n    position.character >= range.start.character\n  ) {\n    if (\n      position.line === range.end.line &&\n      position.character > range.end.character\n    ) {\n      return false\n    } else {\n      return true\n    }\n  }\n  if (\n    position.line === range.end.line &&\n    position.character <= range.end.character\n  ) {\n    if (\n      position.line === range.start.line &&\n      position.character < range.end.character\n    ) {\n      return false\n    } else {\n      return true\n    }\n  }\n  if (position.line > range.start.line && position.line < range.end.line) {\n    return true\n  }\n  return false\n}\n","// https://www.codementor.io/@agustinchiappeberrini/lazy-evaluation-and-javascript-a5m7g8gs3\n\nexport interface Lazy<T> {\n  (): T\n  isLazy: boolean\n}\n\nexport const lazy = <T>(getter: () => T): Lazy<T> => {\n  let evaluated: boolean = false\n  let _res: T = null\n  const res = <Lazy<T>>function (): T {\n    if (evaluated) return _res\n    _res = getter.apply(this, arguments)\n    evaluated = true\n    return _res\n  }\n  res.isLazy = true\n  return res\n}\n","import moo from 'moo'\nimport { lazy } from './lazy'\n\nconst classAttributeStates: () => { [x: string]: moo.Rules } = () => ({\n  doubleClassList: {\n    arb: { match: new RegExp('(?<!\\\\\\\\)\\\\['), push: 'arbitrary' },\n    lbrace: { match: new RegExp('(?<!\\\\\\\\)\\\\{'), push: 'interpBrace' },\n    rbrace: { match: new RegExp('(?<!\\\\\\\\)\\\\}'), pop: 1 },\n    end: { match: new RegExp('(?<!\\\\\\\\)\"'), pop: 1 },\n    classlist: { match: new RegExp('[\\\\s\\\\S]'), lineBreaks: true },\n  },\n  singleClassList: {\n    lbrace: { match: new RegExp('(?<!\\\\\\\\)\\\\{'), push: 'interpBrace' },\n    rbrace: { match: new RegExp('(?<!\\\\\\\\)\\\\}'), pop: 1 },\n    end: { match: new RegExp(\"(?<!\\\\\\\\)'\"), pop: 1 },\n    classlist: { match: new RegExp('[\\\\s\\\\S]'), lineBreaks: true },\n  },\n  tickClassList: {\n    lbrace: { match: new RegExp('(?<=(?<!\\\\\\\\)\\\\$)\\\\{'), push: 'interpBrace' },\n    rbrace: { match: new RegExp('(?<!\\\\\\\\)\\\\}'), pop: 1 },\n    end: { match: new RegExp('(?<!\\\\\\\\)`'), pop: 1 },\n    classlist: { match: new RegExp('[\\\\s\\\\S]'), lineBreaks: true },\n  },\n  interpBrace: {\n    startSingle: { match: new RegExp(\"(?<!\\\\\\\\)'\"), push: 'singleClassList' },\n    startDouble: { match: new RegExp('(?<!\\\\\\\\)\"'), push: 'doubleClassList' },\n    startTick: { match: new RegExp('(?<!\\\\\\\\)`'), push: 'tickClassList' },\n    lbrace: { match: new RegExp('(?<!\\\\\\\\)\\\\{'), push: 'interpBrace' },\n    rbrace: { match: new RegExp('(?<!\\\\\\\\)\\\\}'), pop: 1 },\n    text: { match: new RegExp('[\\\\s\\\\S]'), lineBreaks: true },\n  },\n  interpSingle: {\n    startDouble: { match: new RegExp('(?<!\\\\\\\\)\"'), push: 'doubleClassList' },\n    startTick: { match: new RegExp('(?<!\\\\\\\\)`'), push: 'tickClassList' },\n    single: { match: new RegExp(\"(?<!\\\\\\\\)'\"), pop: 1 },\n    text: { match: new RegExp('[\\\\s\\\\S]'), lineBreaks: true },\n  },\n  interpDouble: {\n    startSingle: { match: new RegExp(\"(?<!\\\\\\\\)'\"), push: 'singleClassList' },\n    startTick: { match: new RegExp('(?<!\\\\\\\\)`'), push: 'tickClassList' },\n    double: { match: new RegExp('(?<!\\\\\\\\)\"'), pop: 1 },\n    text: { match: new RegExp('[\\\\s\\\\S]'), lineBreaks: true },\n  },\n  arbitrary: {\n    arb: { match: new RegExp('(?<!\\\\\\\\)\\\\]'), pop: 1 },\n    space: { match: /\\s/, pop: 1, lineBreaks: true },\n    arb2: { match: new RegExp('[\\\\s\\\\S]'), lineBreaks: true },\n  },\n})\n\nconst simpleClassAttributeStates: { [x: string]: moo.Rules } = {\n  main: {\n    start: { match: '\"', push: 'doubleClassList' },\n  },\n  doubleClassList: {\n    end: { match: '\"', pop: 1 },\n    classlist: { match: /[\\s\\S]/, lineBreaks: true },\n  },\n}\n\nexport const getClassAttributeLexer = lazy(() => {\n  let supportsNegativeLookbehind = true\n  try {\n    new RegExp('(?<!)')\n  } catch (_) {\n    supportsNegativeLookbehind = false\n  }\n\n  if (supportsNegativeLookbehind) {\n    return moo.states({\n      main: {\n        start1: { match: '\"', push: 'doubleClassList' },\n        start2: { match: \"'\", push: 'singleClassList' },\n        start3: { match: '{', push: 'interpBrace' },\n      },\n      ...classAttributeStates(),\n    })\n  }\n\n  return moo.states(simpleClassAttributeStates)\n})\n\nexport const getComputedClassAttributeLexer = lazy(() => {\n  let supportsNegativeLookbehind = true\n  try {\n    new RegExp('(?<!)')\n  } catch (_) {\n    supportsNegativeLookbehind = false\n  }\n\n  if (supportsNegativeLookbehind) {\n    return moo.states({\n      main: {\n        lbrace: { match: '{', push: 'interpBrace' },\n        single: { match: \"'\", push: 'interpSingle' },\n        double: { match: '\"', push: 'interpDouble' },\n      },\n      ...classAttributeStates(),\n    })\n  }\n\n  return moo.states(simpleClassAttributeStates)\n})\n","import type { Range } from 'vscode-languageserver'\n\nexport function resolveRange(range: Range, relativeTo?: Range) {\n  return {\n    start: {\n      line: (relativeTo?.start.line || 0) + range.start.line,\n      character:\n        (range.end.line === 0 ? relativeTo?.start.character || 0 : 0) +\n        range.start.character,\n    },\n    end: {\n      line: (relativeTo?.start.line || 0) + range.end.line,\n      character:\n        (range.end.line === 0 ? relativeTo?.start.character || 0 : 0) +\n        range.end.character,\n    },\n  }\n}\n","import type { TextDocument, Range } from 'vscode-languageserver'\nimport moo from 'moo'\n\nexport function getTextWithoutComments(\n  doc: TextDocument,\n  type: 'html' | 'js' | 'jsx' | 'css',\n  range?: Range\n): string\nexport function getTextWithoutComments(text: string, type: 'html' | 'js' | 'jsx' | 'css'): string\nexport function getTextWithoutComments(\n  docOrText: TextDocument | string,\n  type: 'html' | 'js' | 'jsx' | 'css',\n  range?: Range\n): string {\n  let text = typeof docOrText === 'string' ? docOrText : docOrText.getText(range)\n\n  if (type === 'js' || type === 'jsx') {\n    return getJsWithoutComments(text)\n  }\n\n  if (type === 'css') {\n    return text.replace(/\\/\\*.*?\\*\\//gs, replace)\n  }\n\n  return text.replace(/<!--.*?-->/gs, replace)\n}\n\nfunction replace(match: string): string {\n  return match.replace(/./gs, (char) => (char === '\\n' ? '\\n' : ' '))\n}\n\nlet jsLexer: moo.Lexer\n\nfunction getJsWithoutComments(text: string): string {\n  if (!jsLexer) {\n    jsLexer = moo.states({\n      main: {\n        commentLine: /\\/\\/.*?$/,\n        commentBlock: { match: /\\/\\*[^]*?\\*\\//, lineBreaks: true },\n        stringDouble: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n        stringSingle: /'(?:[^'\\\\]|\\\\.)*'/,\n        stringBacktick: /`(?:[^`\\\\]|\\\\.)*`/,\n        other: { match: /[^]/, lineBreaks: true },\n      },\n    })\n  }\n\n  let str = ''\n  jsLexer.reset(text)\n\n  for (let token of jsLexer) {\n    if (token.type === 'commentLine') {\n      str += ' '.repeat(token.value.length)\n    } else if (token.type === 'commentBlock') {\n      str += token.value.replace(/./g, ' ')\n    } else {\n      str += token.value\n    }\n  }\n\n  return str\n}\n","import type { TextDocument, Range, Position } from 'vscode-languageserver'\nimport { DocumentClassName, DocumentClassList, State, DocumentHelperFunction } from './state'\nimport lineColumn from 'line-column'\nimport { isCssContext, isCssDoc } from './css'\nimport { isHtmlContext } from './html'\nimport { isWithinRange } from './isWithinRange'\nimport { isJsxContext } from './js'\nimport { dedupeByRange, flatten } from './array'\nimport { getClassAttributeLexer, getComputedClassAttributeLexer } from './lexers'\nimport { getLanguageBoundaries } from './getLanguageBoundaries'\nimport { resolveRange } from './resolveRange'\nimport Regex from 'becke-ch--regex--s0-0-v1--base--pl--lib'\nimport { getTextWithoutComments } from './doc'\n\nexport function findAll(re: RegExp, str: string): RegExpMatchArray[] {\n  let match: RegExpMatchArray\n  let matches: RegExpMatchArray[] = []\n  while ((match = re.exec(str)) !== null) {\n    matches.push({ ...match })\n  }\n  return matches\n}\n\nexport function findLast(re: RegExp, str: string): RegExpMatchArray {\n  const matches = findAll(re, str)\n  if (matches.length === 0) {\n    return null\n  }\n  return matches[matches.length - 1]\n}\n\nexport function getClassNamesInClassList({\n  classList,\n  range,\n  important,\n}: DocumentClassList): DocumentClassName[] {\n  const parts = classList.split(/(\\s+)/)\n  const names: DocumentClassName[] = []\n  let index = 0\n  for (let i = 0; i < parts.length; i++) {\n    if (i % 2 === 0) {\n      const start = indexToPosition(classList, index)\n      const end = indexToPosition(classList, index + parts[i].length)\n      names.push({\n        className: parts[i],\n        classList: {\n          classList,\n          range,\n          important,\n        },\n        relativeRange: {\n          start,\n          end,\n        },\n        range: {\n          start: {\n            line: range.start.line + start.line,\n            character: (end.line === 0 ? range.start.character : 0) + start.character,\n          },\n          end: {\n            line: range.start.line + end.line,\n            character: (end.line === 0 ? range.start.character : 0) + end.character,\n          },\n        },\n      })\n    }\n    index += parts[i].length\n  }\n  return names\n}\n\nexport async function findClassNamesInRange(\n  state: State,\n  doc: TextDocument,\n  range?: Range,\n  mode?: 'html' | 'css' | 'jsx',\n  includeCustom: boolean = true\n): Promise<DocumentClassName[]> {\n  const classLists = await findClassListsInRange(state, doc, range, mode, includeCustom)\n  return flatten(classLists.map(getClassNamesInClassList))\n}\n\nexport async function findClassNamesInDocument(\n  state: State,\n  doc: TextDocument\n): Promise<DocumentClassName[]> {\n  const classLists = await findClassListsInDocument(state, doc)\n  return flatten(classLists.map(getClassNamesInClassList))\n}\n\nexport function findClassListsInCssRange(doc: TextDocument, range?: Range): DocumentClassList[] {\n  const text = getTextWithoutComments(doc, 'css', range)\n  const matches = findAll(\n    /(@apply\\s+)(?<classList>[^;}]+?)(?<important>\\s*!important)?\\s*[;}]/g,\n    text\n  )\n  const globalStart: Position = range ? range.start : { line: 0, character: 0 }\n\n  return matches.map((match) => {\n    const start = indexToPosition(text, match.index + match[1].length)\n    const end = indexToPosition(text, match.index + match[1].length + match.groups.classList.length)\n    return {\n      classList: match.groups.classList,\n      important: Boolean(match.groups.important),\n      range: {\n        start: {\n          line: globalStart.line + start.line,\n          character: (end.line === 0 ? globalStart.character : 0) + start.character,\n        },\n        end: {\n          line: globalStart.line + end.line,\n          character: (end.line === 0 ? globalStart.character : 0) + end.character,\n        },\n      },\n    }\n  })\n}\n\nasync function findCustomClassLists(\n  state: State,\n  doc: TextDocument,\n  range?: Range\n): Promise<DocumentClassList[]> {\n  const settings = await state.editor.getConfiguration(doc.uri)\n  const regexes = settings.tailwindCSS.experimental.classRegex\n\n  if (!Array.isArray(regexes) || regexes.length === 0) return []\n\n  const text = doc.getText(range)\n  const result: DocumentClassList[] = []\n\n  for (let i = 0; i < regexes.length; i++) {\n    try {\n      let [containerRegexString, classRegexString] = Array.isArray(regexes[i])\n        ? regexes[i]\n        : [regexes[i]]\n\n      let containerRegex = new Regex(containerRegexString, 'g')\n      let containerMatch: ReturnType<Regex['exec']>\n\n      while ((containerMatch = containerRegex.exec(text)) !== null) {\n        const searchStart = doc.offsetAt(range?.start || { line: 0, character: 0 })\n        const matchStart = searchStart + containerMatch.index[1]\n        const matchEnd = matchStart + containerMatch[1].length\n\n        if (classRegexString) {\n          let classRegex = new Regex(classRegexString, 'g')\n          let classMatch: ReturnType<Regex['exec']>\n\n          while ((classMatch = classRegex.exec(containerMatch[1])) !== null) {\n            const classMatchStart = matchStart + classMatch.index[1]\n            const classMatchEnd = classMatchStart + classMatch[1].length\n            result.push({\n              classList: classMatch[1],\n              range: {\n                start: doc.positionAt(classMatchStart),\n                end: doc.positionAt(classMatchEnd),\n              },\n            })\n          }\n        } else {\n          result.push({\n            classList: containerMatch[1],\n            range: {\n              start: doc.positionAt(matchStart),\n              end: doc.positionAt(matchEnd),\n            },\n          })\n        }\n      }\n    } catch (_) {}\n  }\n\n  return result\n}\n\nexport function matchClassAttributes(text: string, attributes: string[]): RegExpMatchArray[] {\n  const attrs = attributes.filter((x) => typeof x === 'string').flatMap((a) => [a, `\\\\[${a}\\\\]`])\n  const re = /(?:\\s|:|\\()(ATTRS)\\s*=\\s*['\"`{]/\n  return findAll(new RegExp(re.source.replace('ATTRS', attrs.join('|')), 'gi'), text)\n}\n\nexport async function findClassListsInHtmlRange(\n  state: State,\n  doc: TextDocument,\n  type: 'html' | 'js' | 'jsx',\n  range?: Range\n): Promise<DocumentClassList[]> {\n  const text = getTextWithoutComments(doc, type, range)\n\n  const matches = matchClassAttributes(\n    text,\n    (await state.editor.getConfiguration(doc.uri)).tailwindCSS.classAttributes\n  )\n\n  const result: DocumentClassList[] = []\n\n  matches.forEach((match) => {\n    const subtext = text.substr(match.index + match[0].length - 1)\n\n    let lexer =\n      match[0][0] === ':' || (match[1].startsWith('[') && match[1].endsWith(']'))\n        ? getComputedClassAttributeLexer()\n        : getClassAttributeLexer()\n    lexer.reset(subtext)\n\n    let classLists: { value: string; offset: number }[] = []\n    let token: moo.Token\n    let currentClassList: { value: string; offset: number }\n\n    try {\n      for (let token of lexer) {\n        if (token.type === 'classlist' || token.type.startsWith('arb')) {\n          if (currentClassList) {\n            currentClassList.value += token.value\n          } else {\n            currentClassList = {\n              value: token.value,\n              offset: token.offset,\n            }\n          }\n        } else {\n          if (currentClassList) {\n            classLists.push({\n              value: currentClassList.value,\n              offset: currentClassList.offset,\n            })\n          }\n          currentClassList = undefined\n        }\n      }\n    } catch (_) {}\n\n    if (currentClassList) {\n      classLists.push({\n        value: currentClassList.value,\n        offset: currentClassList.offset,\n      })\n    }\n\n    result.push(\n      ...classLists\n        .map(({ value, offset }) => {\n          if (value.trim() === '') {\n            return null\n          }\n\n          const before = value.match(/^\\s*/)\n          const beforeOffset = before === null ? 0 : before[0].length\n          const after = value.match(/\\s*$/)\n          const afterOffset = after === null ? 0 : -after[0].length\n\n          const start = indexToPosition(\n            text,\n            match.index + match[0].length - 1 + offset + beforeOffset\n          )\n          const end = indexToPosition(\n            text,\n            match.index + match[0].length - 1 + offset + value.length + afterOffset\n          )\n\n          return {\n            classList: value.substr(beforeOffset, value.length + afterOffset),\n            range: {\n              start: {\n                line: (range?.start.line || 0) + start.line,\n                character: (end.line === 0 ? range?.start.character || 0 : 0) + start.character,\n              },\n              end: {\n                line: (range?.start.line || 0) + end.line,\n                character: (end.line === 0 ? range?.start.character || 0 : 0) + end.character,\n              },\n            },\n          }\n        })\n        .filter((x) => x !== null)\n    )\n  })\n\n  return result\n}\n\nexport async function findClassListsInRange(\n  state: State,\n  doc: TextDocument,\n  range?: Range,\n  mode?: 'html' | 'css' | 'jsx',\n  includeCustom: boolean = true\n): Promise<DocumentClassList[]> {\n  let classLists: DocumentClassList[]\n  if (mode === 'css') {\n    classLists = findClassListsInCssRange(doc, range)\n  } else {\n    classLists = await findClassListsInHtmlRange(state, doc, mode, range)\n  }\n  return dedupeByRange([\n    ...classLists,\n    ...(includeCustom ? await findCustomClassLists(state, doc, range) : []),\n  ])\n}\n\nexport async function findClassListsInDocument(\n  state: State,\n  doc: TextDocument\n): Promise<DocumentClassList[]> {\n  if (isCssDoc(state, doc)) {\n    return findClassListsInCssRange(doc)\n  }\n\n  let boundaries = getLanguageBoundaries(state, doc)\n  if (!boundaries) return []\n\n  return dedupeByRange(\n    flatten([\n      ...(await Promise.all(\n        boundaries\n          .filter((b) => b.type === 'html' || b.type === 'jsx')\n          .map(({ type, range }) =>\n            findClassListsInHtmlRange(state, doc, type === 'html' ? 'html' : 'jsx', range)\n          )\n      )),\n      ...boundaries\n        .filter((b) => b.type === 'css')\n        .map(({ range }) => findClassListsInCssRange(doc, range)),\n      await findCustomClassLists(state, doc),\n    ])\n  )\n}\n\nexport function findHelperFunctionsInDocument(\n  state: State,\n  doc: TextDocument\n): DocumentHelperFunction[] {\n  if (isCssDoc(state, doc)) {\n    return findHelperFunctionsInRange(doc)\n  }\n\n  let boundaries = getLanguageBoundaries(state, doc)\n  if (!boundaries) return []\n\n  return flatten(\n    boundaries\n      .filter((b) => b.type === 'css')\n      .map(({ range }) => findHelperFunctionsInRange(doc, range))\n  )\n}\n\nexport function findHelperFunctionsInRange(\n  doc: TextDocument,\n  range?: Range\n): DocumentHelperFunction[] {\n  const text = getTextWithoutComments(doc, 'css', range)\n  let matches = findAll(\n    /(?<prefix>[\\s:;/*(){}])(?<helper>config|theme)(?<innerPrefix>\\(\\s*)(?<path>[^)]*?)\\s*\\)/g,\n    text\n  )\n\n  return matches.map((match) => {\n    let quotesBefore = ''\n    let path = match.groups.path.replace(/['\"]+$/, '').replace(/^['\"]+/, (m) => {\n      quotesBefore = m\n      return ''\n    })\n    let matches = path.match(/^([^\\s]+)(?![^\\[]*\\])(?:\\s*\\/\\s*([^\\/\\s]+))$/)\n    if (matches) {\n      path = matches[1]\n    }\n    path = path.replace(/['\"]*\\s*$/, '')\n\n    let startIndex =\n      match.index +\n      match.groups.prefix.length +\n      match.groups.helper.length +\n      match.groups.innerPrefix.length\n\n    return {\n      helper: match.groups.helper === 'theme' ? 'theme' : 'config',\n      path,\n      ranges: {\n        full: resolveRange(\n          {\n            start: indexToPosition(text, startIndex),\n            end: indexToPosition(text, startIndex + match.groups.path.length),\n          },\n          range\n        ),\n        path: resolveRange(\n          {\n            start: indexToPosition(text, startIndex + quotesBefore.length),\n            end: indexToPosition(text, startIndex + quotesBefore.length + path.length),\n          },\n          range\n        ),\n      },\n    }\n  })\n}\n\nexport function indexToPosition(str: string, index: number): Position {\n  const { line, col } = lineColumn(str + '\\n', index)\n  return { line: line - 1, character: col - 1 }\n}\n\nexport async function findClassNameAtPosition(\n  state: State,\n  doc: TextDocument,\n  position: Position\n): Promise<DocumentClassName> {\n  let classNames = []\n  const positionOffset = doc.offsetAt(position)\n  const searchRange: Range = {\n    start: doc.positionAt(Math.max(0, positionOffset - 1000)),\n    end: doc.positionAt(positionOffset + 1000),\n  }\n\n  if (isCssContext(state, doc, position)) {\n    classNames = await findClassNamesInRange(state, doc, searchRange, 'css')\n  } else if (isHtmlContext(state, doc, position)) {\n    classNames = await findClassNamesInRange(state, doc, searchRange, 'html')\n  } else if (isJsxContext(state, doc, position)) {\n    classNames = await findClassNamesInRange(state, doc, searchRange, 'jsx')\n  }\n\n  if (classNames.length === 0) {\n    return null\n  }\n\n  const className = classNames.find(({ range }) => isWithinRange(position, range))\n\n  if (!className) return null\n\n  return className\n}\n","import type { TextDocument, Range } from 'vscode-languageserver'\nimport { isVueDoc, isHtmlDoc, isSvelteDoc } from './html'\nimport { State } from './state'\nimport { indexToPosition } from './find'\nimport { isJsDoc } from './js'\nimport moo from 'moo'\nimport Cache from 'tmp-cache'\nimport { getTextWithoutComments } from './doc'\n\nexport type LanguageBoundary = { type: 'html' | 'js' | 'css' | (string & {}); range: Range }\n\nlet htmlScriptTypes = [\n  // https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html#option-1-use-script-tag\n  'text/html',\n  // https://vuejs.org/guide/essentials/component-basics.html#dom-template-parsing-caveats\n  'text/x-template',\n  // https://github.com/tailwindlabs/tailwindcss-intellisense/issues/722\n  'text/x-handlebars-template',\n]\n\nlet text = { text: { match: /[^]/, lineBreaks: true } }\n\nlet states = {\n  main: {\n    cssBlockStart: { match: /<style(?=[>\\s])/, push: 'cssBlock' },\n    jsBlockStart: { match: '<script', push: 'jsBlock' },\n    ...text,\n  },\n  cssBlock: {\n    styleStart: { match: '>', next: 'style' },\n    cssBlockEnd: { match: '/>', pop: 1 },\n    attrStartDouble: { match: '\"', push: 'attrDouble' },\n    attrStartSingle: { match: \"'\", push: 'attrSingle' },\n    interp: { match: '{', push: 'interp' },\n    ...text,\n  },\n  jsBlock: {\n    scriptStart: { match: '>', next: 'script' },\n    jsBlockEnd: { match: '/>', pop: 1 },\n    langAttrStartDouble: { match: 'lang=\"', push: 'langAttrDouble' },\n    langAttrStartSingle: { match: \"lang='\", push: 'langAttrSingle' },\n    typeAttrStartDouble: { match: 'type=\"', push: 'typeAttrDouble' },\n    typeAttrStartSingle: { match: \"type='\", push: 'typeAttrSingle' },\n    attrStartDouble: { match: '\"', push: 'attrDouble' },\n    attrStartSingle: { match: \"'\", push: 'attrSingle' },\n    interp: { match: '{', push: 'interp' },\n    ...text,\n  },\n  interp: {\n    interp: { match: '{', push: 'interp' },\n    end: { match: '}', pop: 1 },\n    ...text,\n  },\n  langAttrDouble: {\n    langAttrEnd: { match: '\"', pop: 1 },\n    lang: { match: /[^\"]+/, lineBreaks: true },\n  },\n  langAttrSingle: {\n    langAttrEnd: { match: \"'\", pop: 1 },\n    lang: { match: /[^']+/, lineBreaks: true },\n  },\n  typeAttrDouble: {\n    langAttrEnd: { match: '\"', pop: 1 },\n    type: { match: /[^\"]+/, lineBreaks: true },\n  },\n  typeAttrSingle: {\n    langAttrEnd: { match: \"'\", pop: 1 },\n    type: { match: /[^']+/, lineBreaks: true },\n  },\n  attrDouble: {\n    attrEnd: { match: '\"', pop: 1 },\n    ...text,\n  },\n  attrSingle: {\n    attrEnd: { match: \"'\", pop: 1 },\n    ...text,\n  },\n  style: {\n    cssBlockEnd: { match: '</style>', pop: 1 },\n    ...text,\n  },\n  script: {\n    jsBlockEnd: { match: '</script>', pop: 1 },\n    ...text,\n  },\n}\n\nlet vueStates = {\n  ...states,\n  main: {\n    htmlBlockStart: { match: '<template', push: 'htmlBlock' },\n    ...states.main,\n  },\n  htmlBlock: {\n    htmlStart: { match: '>', next: 'html' },\n    htmlBlockEnd: { match: '/>', pop: 1 },\n    attrStartDouble: { match: '\"', push: 'attrDouble' },\n    attrStartSingle: { match: \"'\", push: 'attrSingle' },\n    interp: { match: '{', push: 'interp' },\n    ...text,\n  },\n  html: {\n    htmlBlockEnd: { match: '</template>', pop: 1 },\n    nestedBlockStart: { match: '<template', push: 'nestedBlock' },\n    ...text,\n  },\n  nestedBlock: {\n    nestedStart: { match: '>', next: 'nested' },\n    nestedBlockEnd: { match: '/>', pop: 1 },\n    ...text,\n  },\n  nested: {\n    nestedBlockEnd: { match: '</template>', pop: 1 },\n    nestedBlockStart: { match: '<template', push: 'nestedBlock' },\n    ...text,\n  },\n}\n\nlet defaultLexer = moo.states(states)\nlet vueLexer = moo.states(vueStates)\n\nlet cache = new Cache<string, LanguageBoundary[] | null>({ max: 25, maxAge: 1000 })\n\nexport function getLanguageBoundaries(\n  state: State,\n  doc: TextDocument,\n  text: string = doc.getText()\n): LanguageBoundary[] | null {\n  let cacheKey = `${doc.languageId}:${text}`\n\n  let cachedBoundaries = cache.get(cacheKey)\n  if (cachedBoundaries !== undefined) {\n    return cachedBoundaries\n  }\n\n  let isJs = isJsDoc(state, doc)\n\n  let defaultType = isVueDoc(doc)\n    ? 'none'\n    : isHtmlDoc(state, doc) || isSvelteDoc(doc)\n    ? 'html'\n    : isJs\n    ? 'jsx'\n    : null\n\n  if (defaultType === null) {\n    cache.set(cacheKey, null)\n    return null\n  }\n\n  text = getTextWithoutComments(text, isJs ? 'js' : 'html')\n\n  let lexer = defaultType === 'none' ? vueLexer : defaultLexer\n  lexer.reset(text)\n\n  let type = defaultType\n  let boundaries: LanguageBoundary[] = [\n    { type: defaultType, range: { start: { line: 0, character: 0 }, end: undefined } },\n  ]\n  let offset = 0\n\n  try {\n    for (let token of lexer) {\n      if (!token.type.startsWith('nested')) {\n        if (token.type.endsWith('BlockStart')) {\n          let position = indexToPosition(text, offset)\n          if (!boundaries[boundaries.length - 1].range.end) {\n            boundaries[boundaries.length - 1].range.end = position\n          }\n          type = token.type.replace(/BlockStart$/, '')\n          boundaries.push({ type, range: { start: position, end: undefined } })\n        } else if (token.type.endsWith('BlockEnd')) {\n          let position = indexToPosition(text, offset)\n          boundaries[boundaries.length - 1].range.end = position\n          boundaries.push({ type: defaultType, range: { start: position, end: undefined } })\n        } else if (token.type === 'lang') {\n          boundaries[boundaries.length - 1].type = token.text\n        } else if (token.type === 'type' && htmlScriptTypes.includes(token.text)) {\n          boundaries[boundaries.length - 1].type = 'html'\n        }\n      }\n      offset += token.text.length\n    }\n  } catch {\n    cache.set(cacheKey, null)\n    return null\n  }\n\n  if (!boundaries[boundaries.length - 1].range.end) {\n    boundaries[boundaries.length - 1].range.end = indexToPosition(text, offset)\n  }\n\n  cache.set(cacheKey, boundaries)\n\n  return boundaries\n}\n","import type { TextDocument, Position } from 'vscode-languageserver'\nimport { State } from './state'\nimport { htmlLanguages } from './languages'\nimport { getLanguageBoundaries } from './getLanguageBoundaries'\n\nexport function isHtmlDoc(state: State, doc: TextDocument): boolean {\n  const userHtmlLanguages = Object.keys(state.editor.userLanguages).filter((lang) =>\n    htmlLanguages.includes(state.editor.userLanguages[lang])\n  )\n\n  return [...htmlLanguages, ...userHtmlLanguages].indexOf(doc.languageId) !== -1\n}\n\nexport function isVueDoc(doc: TextDocument): boolean {\n  return doc.languageId === 'vue'\n}\n\nexport function isSvelteDoc(doc: TextDocument): boolean {\n  return doc.languageId === 'svelte'\n}\n\nexport function isHtmlContext(state: State, doc: TextDocument, position: Position): boolean {\n  let str = doc.getText({\n    start: { line: 0, character: 0 },\n    end: position,\n  })\n\n  let boundaries = getLanguageBoundaries(state, doc, str)\n\n  return boundaries ? boundaries[boundaries.length - 1].type === 'html' : false\n}\n","import removeMeta from './removeMeta'\nimport dlv from 'dlv'\nimport escapeClassName from 'css.escape'\nimport { ensureArray } from './array'\nimport { remToPx } from './remToPx'\nimport stringifyObject from 'stringify-object'\nimport isObject from './isObject'\nimport { Settings } from './state'\n\nexport function stringifyConfigValue(x: any): string {\n  if (isObject(x)) return `${Object.keys(x).length} values`\n  if (typeof x === 'function') return 'ƒ'\n  return stringifyObject(x, {\n    inlineCharacterLimit: Infinity,\n    singleQuotes: false,\n    transform: (obj, prop, originalResult) => {\n      if (typeof obj[prop] === 'function') {\n        return 'ƒ'\n      }\n      return originalResult\n    },\n  })\n}\n\nexport function stringifyCss(className: string, obj: any, settings: Settings): string {\n  if (obj.__rule !== true && !Array.isArray(obj)) return null\n\n  if (Array.isArray(obj)) {\n    const rules = obj.map((x) => stringifyCss(className, x, settings)).filter(Boolean)\n    if (rules.length === 0) return null\n    return rules.join('\\n\\n')\n  }\n\n  let css = ``\n  const indent = ' '.repeat(settings.editor.tabSize)\n\n  const context = dlv(obj, '__context', [])\n  const props = Object.keys(removeMeta(obj))\n  if (props.length === 0) return null\n\n  for (let i = 0; i < context.length; i++) {\n    css += `${indent.repeat(i)}${context[i]} {\\n`\n  }\n\n  const indentStr = indent.repeat(context.length)\n  const decls = props.reduce((acc, curr, i) => {\n    const propStr = ensureArray(obj[curr])\n      .map((val) => {\n        const px = settings.tailwindCSS.showPixelEquivalents\n          ? remToPx(val, settings.tailwindCSS.rootFontSize)\n          : undefined\n        return `${indentStr + indent}${curr}: ${val}${px ? `/* ${px} */` : ''};`\n      })\n      .join('\\n')\n    return `${acc}${i === 0 ? '' : '\\n'}${propStr}`\n  }, '')\n  css += `${indentStr}${augmentClassName(className, obj)} {\\n${decls}\\n${indentStr}}`\n\n  for (let i = context.length - 1; i >= 0; i--) {\n    css += `${indent.repeat(i)}\\n}`\n  }\n\n  return css\n}\n\nfunction augmentClassName(className: string, obj: any): string {\n  const pseudo = obj.__pseudo.join('')\n  const scope = obj.__scope ? `${obj.__scope} ` : ''\n  return `${scope}.${escapeClassName(className)}${pseudo}`\n}\n","export function naturalExpand(value: number, total?: number): string {\n  let length = typeof total === 'number' ? total.toString().length : 8\n  return ('0'.repeat(length) + value).slice(-length)\n}\n","import semverGte from 'semver/functions/gte'\nimport semverLte from 'semver/functions/lte'\n\nexport function gte(v1: string, v2: string): boolean {\n  if (v1.startsWith('0.0.0-insiders')) {\n    return true\n  }\n  return semverGte(v1, v2)\n}\n\nexport function lte(v1: string, v2: string): boolean {\n  if (v1.startsWith('0.0.0-insiders')) {\n    return false\n  }\n  return semverLte(v1, v2)\n}\n","import * as semver from './semver'\n\nexport function docsUrl(version: string, paths: string | string[]): string {\n  let major = 0\n  let url = 'https://tailwindcss-v0.netlify.app/docs/'\n  if (semver.gte(version, '0.99.0')) {\n    major = 1\n    url = 'https://v1.tailwindcss.com/docs/'\n  }\n  if (semver.gte(version, '1.99.0')) {\n    major = 2\n    url = 'https://tailwindcss.com/docs/'\n  }\n  const path = Array.isArray(paths) ? paths[major] || paths[paths.length - 1] : paths\n  return `${url}${path}`\n}\n","import { State, ClassNameMeta } from './state'\nimport { getClassNameParts } from './getClassNameAtPosition'\nimport dlv from 'dlv'\n\nexport function getClassNameMeta(\n  state: State,\n  classNameOrParts: string | string[]\n): ClassNameMeta | ClassNameMeta[] {\n  const parts = Array.isArray(classNameOrParts)\n    ? classNameOrParts\n    : getClassNameParts(state, classNameOrParts)\n  if (!parts) return null\n  const info = dlv(state.classNames.classNames, [...parts, '__info'])\n\n  if (Array.isArray(info)) {\n    return info.map((i) => ({\n      source: i.__source,\n      pseudo: i.__pseudo,\n      scope: i.__scope,\n      context: i.__context,\n    }))\n  }\n\n  return {\n    source: info.__source,\n    pseudo: info.__pseudo,\n    scope: info.__scope,\n    context: info.__context,\n  }\n}\n","import { State } from './state'\nimport dlv from 'dlv'\n\nexport function flagEnabled(state: State, flag: string) {\n  if (state.featureFlags.future.includes(flag)) {\n    return (\n      state.config.future === 'all' ||\n      dlv(state.config, ['future', flag], false)\n    )\n  }\n\n  if (state.featureFlags.experimental.includes(flag)) {\n    return (\n      state.config.experimental === 'all' ||\n      dlv(state.config, ['experimental', flag], false)\n    )\n  }\n\n  return false\n}\n","import { State } from './state'\nimport { getClassNameMeta } from './getClassNameMeta'\nimport { flagEnabled } from './flagEnabled'\nimport * as semver from './semver'\n\nexport function validateApply(\n  state: State,\n  classNameOrParts: string | string[]\n): { isApplyable: true } | { isApplyable: false; reason: string } | null {\n  if (state.jit) {\n    return { isApplyable: true }\n  }\n\n  const meta = getClassNameMeta(state, classNameOrParts)\n  if (!meta) return null\n\n  if (semver.gte(state.version, '2.0.0-alpha.1') || flagEnabled(state, 'applyComplexClasses')) {\n    return { isApplyable: true }\n  }\n\n  const className = Array.isArray(classNameOrParts)\n    ? classNameOrParts.join(state.separator)\n    : classNameOrParts\n\n  let reason: string\n\n  if (Array.isArray(meta)) {\n    reason = `'@apply' cannot be used with '${className}' because it is included in multiple rulesets.`\n  } else if (meta.source !== 'utilities') {\n    reason = `'@apply' cannot be used with '${className}' because it is not a utility.`\n  } else if (meta.context && meta.context.length > 0) {\n    if (meta.context.length === 1) {\n      reason = `'@apply' cannot be used with '${className}' because it is nested inside of an at-rule ('${meta.context[0]}').`\n    } else {\n      reason = `'@apply' cannot be used with '${className}' because it is nested inside of at-rules (${meta.context\n        .map((c) => `'${c}'`)\n        .join(', ')}).`\n    }\n  } else if (meta.pseudo && meta.pseudo.length > 0) {\n    if (meta.pseudo.length === 1) {\n      reason = `'@apply' cannot be used with '${className}' because its definition includes a pseudo-selector ('${meta.pseudo[0]}')`\n    } else {\n      reason = `'@apply' cannot be used with '${className}' because its definition includes pseudo-selectors (${meta.pseudo\n        .map((p) => `'${p}'`)\n        .join(', ')}).`\n    }\n  }\n\n  if (reason) {\n    return { isApplyable: false, reason }\n  }\n\n  return { isApplyable: true }\n}\n","import { State } from './state'\nimport * as jit from './jit'\n\nexport function getVariantsFromClassName(\n  state: State,\n  className: string\n): { variants: string[]; offset: number } {\n  let allVariants = state.variants.flatMap((variant) => {\n    if (variant.values.length) {\n      return variant.values.map((value) =>\n        value === 'DEFAULT' ? variant.name : `${variant.name}${variant.hasDash ? '-' : ''}${value}`\n      )\n    }\n    return [variant.name]\n  })\n  let variants = new Set<string>()\n  let offset = 0\n  let parts = splitAtTopLevelOnly(className, state.separator)\n  if (parts.length < 2) {\n    return { variants: Array.from(variants), offset }\n  }\n  parts = parts.filter(Boolean)\n\n  for (let part of parts) {\n    if (\n      allVariants.includes(part) ||\n      (state.jit &&\n        ((part.includes('[') && part.endsWith(']')) || part.includes('/')) &&\n        jit.generateRules(state, [`${part}${state.separator}[color:red]`]).rules.length > 0)\n    ) {\n      variants.add(part)\n      offset += part.length + state.separator.length\n      continue\n    }\n\n    break\n  }\n\n  return { variants: Array.from(variants), offset }\n}\n\n// https://github.com/tailwindlabs/tailwindcss/blob/a8a2e2a7191fbd4bee044523aecbade5823a8664/src/util/splitAtTopLevelOnly.js\nfunction splitAtTopLevelOnly(input: string, separator: string): string[] {\n  let stack: string[] = []\n  let parts: string[] = []\n  let lastPos = 0\n\n  for (let idx = 0; idx < input.length; idx++) {\n    let char = input[idx]\n\n    if (stack.length === 0 && char === separator[0]) {\n      if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {\n        parts.push(input.slice(lastPos, idx))\n        lastPos = idx + separator.length\n      }\n    }\n\n    if (char === '(' || char === '[' || char === '{') {\n      stack.push(char)\n    } else if (\n      (char === ')' && stack[stack.length - 1] === '(') ||\n      (char === ']' && stack[stack.length - 1] === '[') ||\n      (char === '}' && stack[stack.length - 1] === '{')\n    ) {\n      stack.pop()\n    }\n  }\n\n  parts.push(input.slice(lastPos))\n\n  return parts\n}\n","import { Settings, State } from './util/state'\nimport type {\n  CompletionItem,\n  CompletionItemKind,\n  Range,\n  MarkupKind,\n  CompletionList,\n  TextDocument,\n  Position,\n  CompletionContext,\n} from 'vscode-languageserver'\nimport dlv from 'dlv'\nimport removeMeta from './util/removeMeta'\nimport { getColor, getColorFromValue } from './util/color'\nimport { isHtmlContext } from './util/html'\nimport { isCssContext } from './util/css'\nimport { findLast, matchClassAttributes } from './util/find'\nimport { stringifyConfigValue, stringifyCss } from './util/stringify'\nimport { stringifyScreen, Screen } from './util/screens'\nimport isObject from './util/isObject'\nimport * as emmetHelper from 'vscode-emmet-helper-bundled'\nimport { isValidLocationForEmmetAbbreviation } from './util/isValidLocationForEmmetAbbreviation'\nimport { isJsDoc, isJsxContext } from './util/js'\nimport { naturalExpand } from './util/naturalExpand'\nimport * as semver from './util/semver'\nimport { docsUrl } from './util/docsUrl'\nimport { ensureArray } from './util/array'\nimport { getClassAttributeLexer, getComputedClassAttributeLexer } from './util/lexers'\nimport { validateApply } from './util/validateApply'\nimport { flagEnabled } from './util/flagEnabled'\nimport { remToPx } from './util/remToPx'\nimport * as jit from './util/jit'\nimport { getVariantsFromClassName } from './util/getVariantsFromClassName'\nimport * as culori from 'culori'\nimport Regex from 'becke-ch--regex--s0-0-v1--base--pl--lib'\n\nlet isUtil = (className) =>\n  Array.isArray(className.__info)\n    ? className.__info.some((x) => x.__source === 'utilities')\n    : className.__info.__source === 'utilities'\n\nexport function completionsFromClassList(\n  state: State,\n  classList: string,\n  classListRange: Range,\n  filter?: (item: CompletionItem) => boolean,\n  context?: CompletionContext\n): CompletionList {\n  let classNames = classList.split(/[\\s+]/)\n  const partialClassName = classNames[classNames.length - 1]\n  let sep = state.separator\n  let parts = partialClassName.split(sep)\n  let subset: any\n  let subsetKey: string[] = []\n  let isSubset: boolean = false\n\n  let replacementRange = {\n    ...classListRange,\n    start: {\n      ...classListRange.start,\n      character: classListRange.end.character - partialClassName.length,\n    },\n  }\n\n  if (state.jit) {\n    let { variants: existingVariants, offset } = getVariantsFromClassName(state, partialClassName)\n\n    if (\n      context &&\n      (context.triggerKind === 1 ||\n        (context.triggerKind === 2 && context.triggerCharacter === '/')) &&\n      partialClassName.includes('/')\n    ) {\n      // modifiers\n      let modifiers: string[]\n      let beforeSlash = partialClassName.split('/').slice(0, -1).join('/')\n\n      if (state.classListContainsMetadata) {\n        let baseClassName = beforeSlash.slice(offset)\n        modifiers = state.classList.find(\n          (cls) => Array.isArray(cls) && cls[0] === baseClassName\n        )?.[1]?.modifiers\n      } else {\n        let testClass = beforeSlash + '/[0]'\n        let { rules } = jit.generateRules(state, [testClass])\n        if (rules.length > 0) {\n          let opacities = dlv(state.config, 'theme.opacity', {})\n          if (!isObject(opacities)) {\n            opacities = {}\n          }\n          modifiers = Object.keys(opacities)\n        }\n      }\n\n      if (modifiers) {\n        return withDefaults(\n          {\n            isIncomplete: false,\n            items: modifiers.map((modifier, index) => {\n              let className = `${beforeSlash}/${modifier}`\n              let kind: CompletionItemKind = 21\n              let documentation: string | undefined\n\n              const color = getColor(state, className)\n              if (color !== null) {\n                kind = 16\n                if (typeof color !== 'string' && (color.alpha ?? 1) !== 0) {\n                  documentation = culori.formatRgb(color)\n                }\n              }\n\n              return {\n                label: className,\n                ...(documentation ? { documentation } : {}),\n                kind,\n                sortText: naturalExpand(index),\n              }\n            }),\n          },\n          {\n            range: replacementRange,\n            data: state.completionItemData,\n          },\n          state.editor.capabilities.itemDefaults\n        )\n      }\n    }\n\n    replacementRange.start.character += offset\n\n    let important = partialClassName.substr(offset).startsWith('!')\n    if (important) {\n      replacementRange.start.character += 1\n    }\n\n    let items: CompletionItem[] = []\n\n    if (!important) {\n      let variantOrder = 0\n\n      function variantItem(\n        item: Omit<CompletionItem, 'kind' | 'data' | 'command' | 'sortText' | 'textEdit'>\n      ): CompletionItem {\n        return {\n          kind: 9,\n          data: {\n            ...(state.completionItemData ?? {}),\n            _type: 'variant',\n          },\n          command:\n            item.insertTextFormat === 2 // Snippet\n              ? undefined\n              : {\n                  title: '',\n                  command: 'editor.action.triggerSuggest',\n                },\n          sortText: '-' + naturalExpand(variantOrder++),\n          ...item,\n        }\n      }\n\n      items.push(\n        ...state.variants.flatMap((variant) => {\n          let items: CompletionItem[] = []\n\n          if (variant.isArbitrary) {\n            items.push(\n              variantItem({\n                label: `${variant.name}${variant.hasDash ? '-' : ''}[]${sep}`,\n                insertTextFormat: 2,\n                textEditText: `${variant.name}${variant.hasDash ? '-' : ''}[\\${1}]${sep}\\${0}`,\n                // command: {\n                //   title: '',\n                //   command: 'tailwindCSS.onInsertArbitraryVariantSnippet',\n                //   arguments: [variant.name, replacementRange],\n                // },\n              })\n            )\n          } else if (!existingVariants.includes(variant.name)) {\n            let shouldSortVariants = !semver.gte(state.version, '2.99.0')\n            let resultingVariants = [...existingVariants, variant.name]\n\n            if (shouldSortVariants) {\n              let allVariants = state.variants.map(({ name }) => name)\n              resultingVariants = resultingVariants.sort(\n                (a, b) => allVariants.indexOf(b) - allVariants.indexOf(a)\n              )\n            }\n\n            items.push(\n              variantItem({\n                label: `${variant.name}${sep}`,\n                detail: variant.selectors().join(', '),\n                textEditText: resultingVariants[resultingVariants.length - 1] + sep,\n                additionalTextEdits:\n                  shouldSortVariants && resultingVariants.length > 1\n                    ? [\n                        {\n                          newText:\n                            resultingVariants.slice(0, resultingVariants.length - 1).join(sep) +\n                            sep,\n                          range: {\n                            start: {\n                              ...classListRange.start,\n                              character: classListRange.end.character - partialClassName.length,\n                            },\n                            end: {\n                              ...replacementRange.start,\n                              character: replacementRange.start.character,\n                            },\n                          },\n                        },\n                      ]\n                    : [],\n              })\n            )\n          }\n\n          if (variant.values.length) {\n            items.push(\n              ...variant.values\n                .filter((value) => !existingVariants.includes(`${variant.name}-${value}`))\n                .map((value) =>\n                  variantItem({\n                    label:\n                      value === 'DEFAULT'\n                        ? `${variant.name}${sep}`\n                        : `${variant.name}${variant.hasDash ? '-' : ''}${value}${sep}`,\n                    detail: variant.selectors({ value }).join(', '),\n                  })\n                )\n            )\n          }\n\n          return items\n        })\n      )\n    }\n\n    if (state.classList) {\n      return withDefaults(\n        {\n          isIncomplete: false,\n          items: items.concat(\n            state.classList.map(([className, { color }], index) => {\n              let kind: CompletionItemKind = color ? 16 : 21\n              let documentation: string | undefined\n\n              if (color && typeof color !== 'string') {\n                documentation = culori.formatRgb(color)\n              }\n\n              return {\n                label: className,\n                kind,\n                ...(documentation ? { documentation } : {}),\n                sortText: naturalExpand(index, state.classList.length),\n              } as CompletionItem\n            })\n          ),\n        },\n        {\n          data: {\n            ...(state.completionItemData ?? {}),\n            ...(important ? { important } : {}),\n            variants: existingVariants,\n          },\n          range: replacementRange,\n        },\n        state.editor.capabilities.itemDefaults\n      )\n    }\n\n    return withDefaults(\n      {\n        isIncomplete: false,\n        items: items\n          .concat(\n            Object.keys(state.classNames.classNames)\n              .filter((className) => {\n                let item = state.classNames.classNames[className]\n                if (existingVariants.length === 0) {\n                  return item.__info\n                }\n                return item.__info && isUtil(item)\n              })\n              .map((className, index, classNames) => {\n                let kind: CompletionItemKind = 21\n                let documentation: string | undefined\n\n                const color = getColor(state, className)\n                if (color !== null) {\n                  kind = 16\n                  if (typeof color !== 'string' && (color.alpha ?? 1) !== 0) {\n                    documentation = culori.formatRgb(color)\n                  }\n                }\n\n                return {\n                  label: className,\n                  kind,\n                  ...(documentation ? { documentation } : {}),\n                  sortText: naturalExpand(index, classNames.length),\n                } as CompletionItem\n              })\n          )\n          .filter((item) => {\n            if (item === null) {\n              return false\n            }\n            if (filter && !filter(item)) {\n              return false\n            }\n            return true\n          }),\n      },\n      {\n        range: replacementRange,\n        data: {\n          ...(state.completionItemData ?? {}),\n          variants: existingVariants,\n          ...(important ? { important } : {}),\n        },\n      },\n      state.editor.capabilities.itemDefaults\n    )\n  }\n\n  for (let i = parts.length - 1; i > 0; i--) {\n    let keys = parts.slice(0, i).filter(Boolean)\n    subset = dlv(state.classNames.classNames, keys)\n    if (typeof subset !== 'undefined' && typeof dlv(subset, ['__info', '__rule']) === 'undefined') {\n      isSubset = true\n      subsetKey = keys\n      replacementRange = {\n        ...replacementRange,\n        start: {\n          ...replacementRange.start,\n          character: replacementRange.start.character + keys.join(sep).length + sep.length,\n        },\n      }\n      break\n    }\n  }\n\n  return withDefaults(\n    {\n      isIncomplete: false,\n      items: Object.keys(isSubset ? subset : state.classNames.classNames)\n        .filter((k) => k !== '__info')\n        .filter((className) => isContextItem(state, [...subsetKey, className]))\n        .map((className, index, classNames): CompletionItem => {\n          return {\n            label: className + sep,\n            kind: 9,\n            command: {\n              title: '',\n              command: 'editor.action.triggerSuggest',\n            },\n            sortText: '-' + naturalExpand(index, classNames.length),\n            data: {\n              ...(state.completionItemData ?? {}),\n              className,\n              variants: subsetKey,\n            },\n          }\n        })\n        .concat(\n          Object.keys(isSubset ? subset : state.classNames.classNames)\n            .filter((className) =>\n              dlv(state.classNames.classNames, [...subsetKey, className, '__info'])\n            )\n            .map((className, index, classNames) => {\n              let kind: CompletionItemKind = 21\n              let documentation: string | undefined\n\n              const color = getColor(state, className)\n              if (color !== null) {\n                kind = 16\n                if (typeof color !== 'string' && (color.alpha ?? 1) !== 0) {\n                  documentation = culori.formatRgb(color)\n                }\n              }\n\n              return {\n                label: className,\n                kind,\n                ...(documentation ? { documentation } : {}),\n                sortText: naturalExpand(index, classNames.length),\n              }\n            })\n        )\n        .filter((item) => {\n          if (item === null) {\n            return false\n          }\n          if (filter && !filter(item)) {\n            return false\n          }\n          return true\n        }),\n    },\n    {\n      range: replacementRange,\n      data: {\n        ...(state.completionItemData ?? {}),\n        variants: subsetKey,\n      },\n    },\n    state.editor.capabilities.itemDefaults\n  )\n}\n\nasync function provideClassAttributeCompletions(\n  state: State,\n  document: TextDocument,\n  position: Position,\n  context?: CompletionContext\n): Promise<CompletionList> {\n  let str = document.getText({\n    start: document.positionAt(Math.max(0, document.offsetAt(position) - 1000)),\n    end: position,\n  })\n\n  let matches = matchClassAttributes(\n    str,\n    (await state.editor.getConfiguration(document.uri)).tailwindCSS.classAttributes\n  )\n\n  if (matches.length === 0) {\n    return null\n  }\n\n  let match = matches[matches.length - 1]\n\n  const lexer =\n    match[0][0] === ':' || (match[1].startsWith('[') && match[1].endsWith(']'))\n      ? getComputedClassAttributeLexer()\n      : getClassAttributeLexer()\n  lexer.reset(str.substr(match.index + match[0].length - 1))\n\n  try {\n    let tokens = Array.from(lexer)\n    let last = tokens[tokens.length - 1]\n    if (last.type.startsWith('start') || last.type === 'classlist' || last.type.startsWith('arb')) {\n      let classList = ''\n      for (let i = tokens.length - 1; i >= 0; i--) {\n        if (tokens[i].type === 'classlist' || tokens[i].type.startsWith('arb')) {\n          classList = tokens[i].value + classList\n        } else {\n          break\n        }\n      }\n\n      return completionsFromClassList(\n        state,\n        classList,\n        {\n          start: {\n            line: position.line,\n            character: position.character - classList.length,\n          },\n          end: position,\n        },\n        undefined,\n        context\n      )\n    }\n  } catch (_) {}\n\n  return null\n}\n\nasync function provideCustomClassNameCompletions(\n  state: State,\n  document: TextDocument,\n  position: Position,\n  context?: CompletionContext\n): Promise<CompletionList> {\n  const settings = await state.editor.getConfiguration(document.uri)\n  const regexes = settings.tailwindCSS.experimental.classRegex\n  if (regexes.length === 0) return null\n\n  const positionOffset = document.offsetAt(position)\n\n  const searchRange: Range = {\n    start: document.positionAt(Math.max(0, positionOffset - 1000)),\n    end: document.positionAt(positionOffset + 1000),\n  }\n\n  let str = document.getText(searchRange)\n\n  for (let i = 0; i < regexes.length; i++) {\n    try {\n      let [containerRegexString, classRegexString] = Array.isArray(regexes[i])\n        ? regexes[i]\n        : [regexes[i]]\n\n      let containerRegex = new Regex(containerRegexString, 'g')\n      let containerMatch: ReturnType<Regex['exec']>\n\n      while ((containerMatch = containerRegex.exec(str)) !== null) {\n        const searchStart = document.offsetAt(searchRange.start)\n        const matchStart = searchStart + containerMatch.index[1]\n        const matchEnd = matchStart + containerMatch[1].length\n        const cursor = document.offsetAt(position)\n        if (cursor >= matchStart && cursor <= matchEnd) {\n          let classList: string\n\n          if (classRegexString) {\n            let classRegex = new Regex(classRegexString, 'g')\n            let classMatch: ReturnType<Regex['exec']>\n\n            while ((classMatch = classRegex.exec(containerMatch[1])) !== null) {\n              const classMatchStart = matchStart + classMatch.index[1]\n              const classMatchEnd = classMatchStart + classMatch[1].length\n              if (cursor >= classMatchStart && cursor <= classMatchEnd) {\n                classList = classMatch[1].substr(0, cursor - classMatchStart)\n              }\n            }\n\n            if (typeof classList === 'undefined') {\n              throw Error()\n            }\n          } else {\n            classList = containerMatch[1].substr(0, cursor - matchStart)\n          }\n\n          return completionsFromClassList(\n            state,\n            classList,\n            {\n              start: {\n                line: position.line,\n                character: position.character - classList.length,\n              },\n              end: position,\n            },\n            undefined,\n            context\n          )\n        }\n      }\n    } catch (_) {}\n  }\n\n  return null\n}\n\nfunction provideAtApplyCompletions(\n  state: State,\n  document: TextDocument,\n  position: Position,\n  context?: CompletionContext\n): CompletionList {\n  let str = document.getText({\n    start: { line: Math.max(position.line - 30, 0), character: 0 },\n    end: position,\n  })\n\n  const match = findLast(/@apply\\s+(?<classList>[^;}]*)$/gi, str)\n\n  if (match === null) {\n    return null\n  }\n\n  const classList = match.groups.classList\n\n  return completionsFromClassList(\n    state,\n    classList,\n    {\n      start: {\n        line: position.line,\n        character: position.character - classList.length,\n      },\n      end: position,\n    },\n    (item) => {\n      if (item.kind === 9) {\n        return (\n          semver.gte(state.version, '2.0.0-alpha.1') || flagEnabled(state, 'applyComplexClasses')\n        )\n      }\n      let variants = item.data?.variants ?? []\n      let className = item.data?.className ?? item.label\n      let validated = validateApply(state, [...variants, className])\n      return validated !== null && validated.isApplyable === true\n    },\n    context\n  )\n}\n\nconst NUMBER_REGEX = /^(\\d+\\.?|\\d*\\.\\d+)$/\nfunction isNumber(str: string): boolean {\n  return NUMBER_REGEX.test(str)\n}\n\nasync function provideClassNameCompletions(\n  state: State,\n  document: TextDocument,\n  position: Position,\n  context?: CompletionContext\n): Promise<CompletionList> {\n  if (isCssContext(state, document, position)) {\n    return provideAtApplyCompletions(state, document, position, context)\n  }\n\n  if (isHtmlContext(state, document, position) || isJsxContext(state, document, position)) {\n    return provideClassAttributeCompletions(state, document, position, context)\n  }\n\n  return null\n}\n\nfunction provideCssHelperCompletions(\n  state: State,\n  document: TextDocument,\n  position: Position\n): CompletionList {\n  if (!isCssContext(state, document, position)) {\n    return null\n  }\n\n  let text = document.getText({\n    start: { line: position.line, character: 0 },\n    // read one extra character so we can see if it's a ] later\n    end: { line: position.line, character: position.character + 1 },\n  })\n\n  const match = text\n    .substr(0, text.length - 1) // don't include that extra character from earlier\n    .match(/[\\s:;/*(){}](?<helper>config|theme)\\(\\s*['\"]?(?<path>[^)'\"]*)$/)\n\n  if (match === null) {\n    return null\n  }\n\n  let alpha: string\n  let path = match.groups.path.replace(/^['\"]+/g, '')\n  let matches = path.match(/^([^\\s]+)(?![^\\[]*\\])(?:\\s*\\/\\s*([^\\/\\s]*))$/)\n  if (matches) {\n    path = matches[1]\n    alpha = matches[2]\n  }\n\n  if (alpha !== undefined) {\n    return null\n  }\n\n  let base = match.groups.helper === 'config' ? state.config : dlv(state.config, 'theme', {})\n  let parts = path.split(/([\\[\\].]+)/)\n  let keys = parts.filter((_, i) => i % 2 === 0)\n  let separators = parts.filter((_, i) => i % 2 !== 0)\n  // let obj =\n  //   keys.length === 1 ? base : dlv(base, keys.slice(0, keys.length - 1), {})\n\n  // if (!isObject(obj)) return null\n\n  function totalLength(arr: string[]): number {\n    return arr.reduce((acc, cur) => acc + cur.length, 0)\n  }\n\n  let obj: any\n  let offset: number = keys[keys.length - 1].length\n  let separator: string = separators.length ? separators[separators.length - 1] : null\n\n  if (keys.length === 1) {\n    obj = base\n  } else {\n    for (let i = keys.length - 1; i > 0; i--) {\n      let o = dlv(base, keys.slice(0, i))\n      if (isObject(o)) {\n        obj = o\n        offset = totalLength(parts.slice(i * 2))\n        separator = separators[i - 1]\n        break\n      }\n    }\n  }\n\n  if (!obj) return null\n\n  let editRange = {\n    start: {\n      line: position.line,\n      character: position.character - offset,\n    },\n    end: position,\n  }\n\n  return withDefaults(\n    {\n      isIncomplete: false,\n      items: Object.keys(obj)\n        .sort((a, z) => {\n          let aIsNumber = isNumber(a)\n          let zIsNumber = isNumber(z)\n          if (aIsNumber && !zIsNumber) {\n            return -1\n          }\n          if (!aIsNumber && zIsNumber) {\n            return 1\n          }\n          if (aIsNumber && zIsNumber) {\n            return parseFloat(a) - parseFloat(z)\n          }\n          return 0\n        })\n        .map((item, index, items) => {\n          let color = getColorFromValue(obj[item])\n          const replaceDot: boolean =\n            item.indexOf('.') !== -1 && separator && separator.endsWith('.')\n          const insertClosingBrace: boolean =\n            text.charAt(text.length - 1) !== ']' &&\n            (replaceDot || (separator && separator.endsWith('[')))\n          const detail = stringifyConfigValue(obj[item])\n\n          return {\n            label: item,\n            sortText: naturalExpand(index, items.length),\n            commitCharacters: [!item.includes('.') && '.', !item.includes('[') && '['].filter(\n              Boolean\n            ),\n            kind: color ? 16 : isObject(obj[item]) ? 9 : 10,\n            // VS Code bug causes some values to not display in some cases\n            detail: detail === '0' || detail === 'transparent' ? `${detail} ` : detail,\n            ...(color && typeof color !== 'string' && (color.alpha ?? 1) !== 0\n              ? { documentation: culori.formatRgb(color) }\n              : {}),\n            ...(insertClosingBrace ? { textEditText: `${item}]` } : {}),\n            additionalTextEdits: replaceDot\n              ? [\n                  {\n                    newText: '[',\n                    range: {\n                      start: {\n                        ...editRange.start,\n                        character: editRange.start.character - 1,\n                      },\n                      end: editRange.start,\n                    },\n                  },\n                ]\n              : [],\n          }\n        }),\n    },\n    {\n      range: editRange,\n      data: {\n        ...(state.completionItemData ?? {}),\n        _type: 'helper',\n      },\n    },\n    state.editor.capabilities.itemDefaults\n  )\n}\n\nfunction provideTailwindDirectiveCompletions(\n  state: State,\n  document: TextDocument,\n  position: Position\n): CompletionList {\n  if (!isCssContext(state, document, position)) {\n    return null\n  }\n\n  let text = document.getText({\n    start: { line: position.line, character: 0 },\n    end: position,\n  })\n\n  const match = text.match(/^\\s*@tailwind\\s+(?<partial>[^\\s]*)$/i)\n\n  if (match === null) return null\n\n  let items = [\n    semver.gte(state.version, '1.0.0-beta.1')\n      ? {\n          label: 'base',\n          documentation: {\n            kind: 'markdown' as typeof MarkupKind.Markdown,\n            value: `This injects Tailwind’s base styles and any base styles registered by plugins.\\n\\n[Tailwind CSS Documentation](${docsUrl(\n              state.version,\n              'functions-and-directives/#tailwind'\n            )})`,\n          },\n        }\n      : {\n          label: 'preflight',\n          documentation: {\n            kind: 'markdown' as typeof MarkupKind.Markdown,\n            value: `This injects Tailwind’s base styles, which is a combination of Normalize.css and some additional base styles.\\n\\n[Tailwind CSS Documentation](${docsUrl(\n              state.version,\n              'functions-and-directives/#tailwind'\n            )})`,\n          },\n        },\n    {\n      label: 'components',\n      documentation: {\n        kind: 'markdown' as typeof MarkupKind.Markdown,\n        value: `This injects Tailwind’s component classes and any component classes registered by plugins.\\n\\n[Tailwind CSS Documentation](${docsUrl(\n          state.version,\n          'functions-and-directives/#tailwind'\n        )})`,\n      },\n    },\n    {\n      label: 'utilities',\n      documentation: {\n        kind: 'markdown' as typeof MarkupKind.Markdown,\n        value: `This injects Tailwind’s utility classes and any utility classes registered by plugins.\\n\\n[Tailwind CSS Documentation](${docsUrl(\n          state.version,\n          'functions-and-directives/#tailwind'\n        )})`,\n      },\n    },\n    state.jit && semver.gte(state.version, '2.1.99')\n      ? {\n          label: 'variants',\n          documentation: {\n            kind: 'markdown' as typeof MarkupKind.Markdown,\n            value: `Use this directive to control where Tailwind injects the utility variants.\\n\\nThis directive is considered an advanced escape hatch and it is recommended to omit it whenever possible. If omitted, Tailwind will append these classes to the very end of your stylesheet by default.\\n\\n[Tailwind CSS Documentation](${docsUrl(\n              state.version,\n              'just-in-time-mode#variants-are-inserted-at-tailwind-variants'\n            )})`,\n          },\n        }\n      : {\n          label: 'screens',\n          documentation: {\n            kind: 'markdown' as typeof MarkupKind.Markdown,\n            value: `Use this directive to control where Tailwind injects the responsive variations of each utility.\\n\\nIf omitted, Tailwind will append these classes to the very end of your stylesheet by default.\\n\\n[Tailwind CSS Documentation](${docsUrl(\n              state.version,\n              'functions-and-directives/#tailwind'\n            )})`,\n          },\n        },\n  ]\n\n  return withDefaults(\n    {\n      isIncomplete: false,\n      items: items.map((item) => ({\n        ...item,\n        kind: 21,\n      })),\n    },\n    {\n      data: {\n        ...(state.completionItemData ?? {}),\n        _type: '@tailwind',\n      },\n      range: {\n        start: {\n          line: position.line,\n          character: position.character - match.groups.partial.length,\n        },\n        end: position,\n      },\n    },\n    state.editor.capabilities.itemDefaults\n  )\n}\n\nfunction provideVariantsDirectiveCompletions(\n  state: State,\n  document: TextDocument,\n  position: Position\n): CompletionList {\n  if (!isCssContext(state, document, position)) {\n    return null\n  }\n\n  if (semver.gte(state.version, '2.99.0')) {\n    return null\n  }\n\n  let text = document.getText({\n    start: { line: position.line, character: 0 },\n    end: position,\n  })\n\n  const match = text.match(/^\\s*@variants\\s+(?<partial>[^}]*)$/i)\n\n  if (match === null) return null\n\n  const parts = match.groups.partial.split(/\\s*,\\s*/)\n\n  if (/\\s+/.test(parts[parts.length - 1])) return null\n\n  let possibleVariants = state.variants.flatMap((variant) => {\n    if (variant.values.length) {\n      return variant.values.map((value) =>\n        value === 'DEFAULT' ? variant.name : `${variant.name}${variant.hasDash ? '-' : ''}${value}`\n      )\n    }\n    return [variant.name]\n  })\n  const existingVariants = parts.slice(0, parts.length - 1)\n\n  if (state.jit) {\n    possibleVariants.unshift('responsive')\n    possibleVariants = possibleVariants.filter((v) => !state.screens.includes(v))\n  }\n\n  return withDefaults(\n    {\n      isIncomplete: false,\n      items: possibleVariants\n        .filter((v) => existingVariants.indexOf(v) === -1)\n        .map((variant, index, variants) => ({\n          // TODO: detail\n          label: variant,\n          kind: 21,\n          sortText: naturalExpand(index, variants.length),\n        })),\n    },\n    {\n      data: {\n        ...(state.completionItemData ?? {}),\n        _type: 'variant',\n      },\n      range: {\n        start: {\n          line: position.line,\n          character: position.character - parts[parts.length - 1].length,\n        },\n        end: position,\n      },\n    },\n    state.editor.capabilities.itemDefaults\n  )\n}\n\nfunction provideLayerDirectiveCompletions(\n  state: State,\n  document: TextDocument,\n  position: Position\n): CompletionList {\n  if (!isCssContext(state, document, position)) {\n    return null\n  }\n\n  let text = document.getText({\n    start: { line: position.line, character: 0 },\n    end: position,\n  })\n\n  const match = text.match(/^\\s*@layer\\s+(?<partial>[^\\s]*)$/i)\n\n  if (match === null) return null\n\n  return withDefaults(\n    {\n      isIncomplete: false,\n      items: ['base', 'components', 'utilities'].map((layer, index, layers) => ({\n        label: layer,\n        kind: 21,\n        sortText: naturalExpand(index, layers.length),\n      })),\n    },\n    {\n      data: {\n        ...(state.completionItemData ?? {}),\n        _type: 'layer',\n      },\n      range: {\n        start: {\n          line: position.line,\n          character: position.character - match.groups.partial.length,\n        },\n        end: position,\n      },\n    },\n    state.editor.capabilities.itemDefaults\n  )\n}\n\nfunction withDefaults(\n  completionList: CompletionList,\n  defaults: Partial<{ data: any; range: Range }>,\n  supportedDefaults: string[]\n): CompletionList {\n  let defaultData = supportedDefaults.includes('data')\n  let defaultRange = supportedDefaults.includes('editRange')\n\n  return {\n    ...completionList,\n    ...(defaultData || defaultRange\n      ? {\n          itemDefaults: {\n            ...(defaultData && defaults.data ? { data: defaults.data } : {}),\n            ...(defaultRange && defaults.range ? { editRange: defaults.range } : {}),\n          },\n        }\n      : {}),\n    items:\n      defaultData && defaultRange\n        ? completionList.items\n        : completionList.items.map(({ textEditText, ...item }) => ({\n            ...item,\n            ...(defaultData || !defaults.data || item.data ? {} : { data: defaults.data }),\n            ...(defaultRange || !defaults.range\n              ? textEditText\n                ? { textEditText }\n                : {}\n              : {\n                  textEdit: {\n                    newText: textEditText ?? item.label,\n                    range: defaults.range,\n                  },\n                }),\n          })),\n  }\n}\n\nfunction provideScreenDirectiveCompletions(\n  state: State,\n  document: TextDocument,\n  position: Position\n): CompletionList {\n  if (!isCssContext(state, document, position)) {\n    return null\n  }\n\n  let text = document.getText({\n    start: { line: position.line, character: 0 },\n    end: position,\n  })\n\n  const match = text.match(/^\\s*@screen\\s+(?<partial>[^\\s]*)$/i)\n\n  if (match === null) return null\n\n  const screens = dlv(state.config, ['screens'], dlv(state.config, ['theme', 'screens'], {}))\n\n  if (!isObject(screens)) return null\n\n  return withDefaults(\n    {\n      isIncomplete: false,\n      items: Object.keys(screens).map((screen, index) => ({\n        label: screen,\n        kind: 21,\n        sortText: naturalExpand(index),\n      })),\n    },\n    {\n      data: {\n        ...(state.completionItemData ?? {}),\n        _type: 'screen',\n      },\n      range: {\n        start: {\n          line: position.line,\n          character: position.character - match.groups.partial.length,\n        },\n        end: position,\n      },\n    },\n    state.editor.capabilities.itemDefaults\n  )\n}\n\nfunction provideCssDirectiveCompletions(\n  state: State,\n  document: TextDocument,\n  position: Position\n): CompletionList {\n  if (!isCssContext(state, document, position)) {\n    return null\n  }\n\n  let text = document.getText({\n    start: { line: position.line, character: 0 },\n    end: position,\n  })\n\n  const match = text.match(/^\\s*@(?<partial>[a-z]*)$/i)\n\n  if (match === null) return null\n\n  const items: CompletionItem[] = [\n    {\n      label: '@tailwind',\n      documentation: {\n        kind: 'markdown' as typeof MarkupKind.Markdown,\n        value: `Use the \\`@tailwind\\` directive to insert Tailwind’s \\`base\\`, \\`components\\`, \\`utilities\\` and \\`${\n          state.jit && semver.gte(state.version, '2.1.99') ? 'variants' : 'screens'\n        }\\` styles into your CSS.\\n\\n[Tailwind CSS Documentation](${docsUrl(\n          state.version,\n          'functions-and-directives/#tailwind'\n        )})`,\n      },\n    },\n    {\n      label: '@screen',\n      documentation: {\n        kind: 'markdown' as typeof MarkupKind.Markdown,\n        value: `The \\`@screen\\` directive allows you to create media queries that reference your breakpoints by name instead of duplicating their values in your own CSS.\\n\\n[Tailwind CSS Documentation](${docsUrl(\n          state.version,\n          'functions-and-directives/#screen'\n        )})`,\n      },\n    },\n    {\n      label: '@apply',\n      documentation: {\n        kind: 'markdown' as typeof MarkupKind.Markdown,\n        value: `Use \\`@apply\\` to inline any existing utility classes into your own custom CSS.\\n\\n[Tailwind CSS Documentation](${docsUrl(\n          state.version,\n          'functions-and-directives/#apply'\n        )})`,\n      },\n    },\n    ...(semver.gte(state.version, '1.8.0')\n      ? [\n          {\n            label: '@layer',\n            documentation: {\n              kind: 'markdown' as typeof MarkupKind.Markdown,\n              value: `Use the \\`@layer\\` directive to tell Tailwind which \"bucket\" a set of custom styles belong to. Valid layers are \\`base\\`, \\`components\\`, and \\`utilities\\`.\\n\\n[Tailwind CSS Documentation](${docsUrl(\n                state.version,\n                'functions-and-directives/#layer'\n              )})`,\n            },\n          },\n        ]\n      : []),\n    ...(semver.gte(state.version, '2.99.0')\n      ? []\n      : [\n          {\n            label: '@variants',\n            documentation: {\n              kind: 'markdown' as typeof MarkupKind.Markdown,\n              value: `You can generate \\`responsive\\`, \\`hover\\`, \\`focus\\`, \\`active\\`, and other variants of your own utilities by wrapping their definitions in the \\`@variants\\` directive.\\n\\n[Tailwind CSS Documentation](${docsUrl(\n                state.version,\n                'functions-and-directives/#variants'\n              )})`,\n            },\n          },\n          {\n            label: '@responsive',\n            documentation: {\n              kind: 'markdown' as typeof MarkupKind.Markdown,\n              value: `You can generate responsive variants of your own classes by wrapping their definitions in the \\`@responsive\\` directive.\\n\\n[Tailwind CSS Documentation](${docsUrl(\n                state.version,\n                'functions-and-directives/#responsive'\n              )})`,\n            },\n          },\n        ]),\n    ...(semver.gte(state.version, '3.2.0')\n      ? [\n          {\n            label: '@config',\n            documentation: {\n              kind: 'markdown' as typeof MarkupKind.Markdown,\n              value: `Use the \\`@config\\` directive to specify which config file Tailwind should use when compiling that CSS file.\\n\\n[Tailwind CSS Documentation](${docsUrl(\n                state.version,\n                'functions-and-directives/#config'\n              )})`,\n            },\n          },\n        ]\n      : []),\n  ]\n\n  return withDefaults(\n    {\n      isIncomplete: false,\n      items: items.map((item) => ({\n        ...item,\n        kind: 14,\n      })),\n    },\n    {\n      data: {\n        ...(state.completionItemData ?? {}),\n        _type: 'directive',\n      },\n      range: {\n        start: {\n          line: position.line,\n          character: position.character - match.groups.partial.length - 1,\n        },\n        end: position,\n      },\n    },\n    state.editor.capabilities.itemDefaults\n  )\n}\n\nasync function provideConfigDirectiveCompletions(\n  state: State,\n  document: TextDocument,\n  position: Position\n): Promise<CompletionList> {\n  if (!isCssContext(state, document, position)) {\n    return null\n  }\n\n  if (!semver.gte(state.version, '3.2.0')) {\n    return null\n  }\n\n  let text = document.getText({ start: { line: position.line, character: 0 }, end: position })\n  let match = text.match(/@config\\s*(?<partial>'[^']*|\"[^\"]*)$/)\n  if (!match) {\n    return null\n  }\n  let partial = match.groups.partial.slice(1) // remove quote\n  let valueBeforeLastSlash = partial.substring(0, partial.lastIndexOf('/'))\n  let valueAfterLastSlash = partial.substring(partial.lastIndexOf('/') + 1)\n\n  return withDefaults(\n    {\n      isIncomplete: false,\n      items: (await state.editor.readDirectory(document, valueBeforeLastSlash || '.'))\n        .filter(([name, type]) => type.isDirectory || /\\.c?js$/.test(name))\n        .map(([name, type]) => ({\n          label: type.isDirectory ? name + '/' : name,\n          kind: type.isDirectory ? 19 : 17,\n          command: type.isDirectory\n            ? { command: 'editor.action.triggerSuggest', title: '' }\n            : undefined,\n        })),\n    },\n    {\n      data: {\n        ...(state.completionItemData ?? {}),\n        _type: 'filesystem',\n      },\n      range: {\n        start: {\n          line: position.line,\n          character: position.character - valueAfterLastSlash.length,\n        },\n        end: position,\n      },\n    },\n    state.editor.capabilities.itemDefaults\n  )\n}\n\nasync function provideEmmetCompletions(\n  state: State,\n  document: TextDocument,\n  position: Position\n): Promise<CompletionList> {\n  let settings = await state.editor.getConfiguration(document.uri)\n  if (settings.tailwindCSS.emmetCompletions !== true) return null\n\n  const isHtml = !isJsDoc(state, document) && isHtmlContext(state, document, position)\n  const isJs = isJsDoc(state, document) || isJsxContext(state, document, position)\n\n  const syntax = isHtml ? 'html' : isJs ? 'jsx' : null\n\n  if (syntax === null) {\n    return null\n  }\n\n  const extractAbbreviationResults = emmetHelper.extractAbbreviation(document, position, true)\n  if (\n    !extractAbbreviationResults ||\n    !emmetHelper.isAbbreviationValid(syntax, extractAbbreviationResults.abbreviation)\n  ) {\n    return null\n  }\n\n  if (\n    !isValidLocationForEmmetAbbreviation(document, extractAbbreviationResults.abbreviationRange)\n  ) {\n    return null\n  }\n\n  if (isJs) {\n    const abbreviation: string = extractAbbreviationResults.abbreviation\n    if (abbreviation.startsWith('this.')) {\n      return null\n    }\n    const symbols = await state.editor.getDocumentSymbols(document.uri)\n    if (\n      symbols &&\n      symbols.find(\n        (symbol) =>\n          abbreviation === symbol.name ||\n          (abbreviation.startsWith(symbol.name + '.') && !/>|\\*|\\+/.test(abbreviation))\n      )\n    ) {\n      return null\n    }\n  }\n\n  const emmetItems = emmetHelper.doComplete(document, position, syntax, {})\n\n  if (!emmetItems || !emmetItems.items || emmetItems.items.length !== 1) {\n    return null\n  }\n\n  // https://github.com/microsoft/vscode/issues/86941\n  if (emmetItems.items[0].label === 'widows: ;') {\n    return null\n  }\n\n  const parts = emmetItems.items[0].label.split('.')\n  if (parts.length < 2) return null\n\n  return completionsFromClassList(state, parts[parts.length - 1], {\n    start: {\n      line: position.line,\n      character: position.character - parts[parts.length - 1].length,\n    },\n    end: position,\n  })\n}\n\nexport async function doComplete(\n  state: State,\n  document: TextDocument,\n  position: Position,\n  context?: CompletionContext\n) {\n  if (state === null) return { items: [], isIncomplete: false }\n\n  const result =\n    (await provideClassNameCompletions(state, document, position, context)) ||\n    provideCssHelperCompletions(state, document, position) ||\n    provideCssDirectiveCompletions(state, document, position) ||\n    provideScreenDirectiveCompletions(state, document, position) ||\n    provideVariantsDirectiveCompletions(state, document, position) ||\n    provideTailwindDirectiveCompletions(state, document, position) ||\n    provideLayerDirectiveCompletions(state, document, position) ||\n    (await provideConfigDirectiveCompletions(state, document, position)) ||\n    (await provideCustomClassNameCompletions(state, document, position, context))\n\n  if (result) return result\n\n  return provideEmmetCompletions(state, document, position)\n}\n\nexport async function resolveCompletionItem(\n  state: State,\n  item: CompletionItem\n): Promise<CompletionItem> {\n  if (\n    ['helper', 'directive', 'variant', 'layer', '@tailwind', 'filesystem'].includes(\n      item.data?._type\n    )\n  ) {\n    return item\n  }\n\n  if (item.data?._type === 'screen') {\n    let screens = dlv(state.config, ['theme', 'screens'], dlv(state.config, ['screens'], {}))\n    if (!isObject(screens)) screens = {}\n    item.detail = stringifyScreen(screens[item.label] as Screen)\n    return item\n  }\n\n  let className = item.data?.className ?? item.label\n  if (item.data?.important) {\n    className = `!${className}`\n  }\n  let variants = item.data?.variants ?? []\n\n  if (state.jit) {\n    if (item.kind === 9) return item\n    if (item.detail && item.documentation) return item\n    let { root, rules } = jit.generateRules(state, [[...variants, className].join(state.separator)])\n    if (rules.length === 0) return item\n    if (!item.detail) {\n      if (rules.length === 1) {\n        item.detail = await jit.stringifyDecls(state, rules[0])\n      } else {\n        item.detail = `${rules.length} rules`\n      }\n    }\n    if (!item.documentation) {\n      item.documentation = {\n        kind: 'markdown' as typeof MarkupKind.Markdown,\n        value: ['```css', await jit.stringifyRoot(state, root), '```'].join('\\n'),\n      }\n    }\n    return item\n  }\n\n  const rules = dlv(state.classNames.classNames, [...variants, className, '__info'])\n  if (item.kind === 9) {\n    item.detail = state.classNames.context[className].join(', ')\n  } else {\n    item.detail = await getCssDetail(state, rules)\n    if (!item.documentation) {\n      const settings = await state.editor.getConfiguration()\n      const css = stringifyCss([...variants, className].join(':'), rules, settings)\n      if (css) {\n        item.documentation = {\n          kind: 'markdown' as typeof MarkupKind.Markdown,\n          value: ['```css', css, '```'].join('\\n'),\n        }\n      }\n    }\n  }\n  return item\n}\n\nfunction isContextItem(state: State, keys: string[]): boolean {\n  const item = dlv(state.classNames.classNames, [keys])\n\n  if (!isObject(item)) {\n    return false\n  }\n  if (!state.classNames.context[keys[keys.length - 1]]) {\n    return false\n  }\n  if (Object.keys(item).filter((x) => x !== '__info').length > 0) {\n    return true\n  }\n\n  return isObject(item.__info) && !item.__info.__rule\n}\n\nfunction stringifyDecls(obj: any, settings: Settings): string {\n  let props = Object.keys(obj)\n  let nonCustomProps = props.filter((prop) => !prop.startsWith('--'))\n\n  if (props.length !== nonCustomProps.length && nonCustomProps.length !== 0) {\n    props = nonCustomProps\n  }\n\n  return props\n    .map((prop) =>\n      ensureArray(obj[prop])\n        .map((value) => {\n          const px = settings.tailwindCSS.showPixelEquivalents\n            ? remToPx(value, settings.tailwindCSS.rootFontSize)\n            : undefined\n          return `${prop}: ${value}${px ? `/* ${px} */` : ''};`\n        })\n        .join(' ')\n    )\n    .join(' ')\n}\n\nasync function getCssDetail(state: State, className: any): Promise<string> {\n  if (Array.isArray(className)) {\n    return `${className.length} rules`\n  }\n  if (className.__rule === true) {\n    const settings = await state.editor.getConfiguration()\n    return stringifyDecls(removeMeta(className), settings)\n  }\n  return null\n}\n","import type { Diagnostic } from 'vscode-languageserver'\nimport { DocumentClassName, DocumentClassList } from '../util/state'\n\nexport enum DiagnosticKind {\n  CssConflict = 'cssConflict',\n  InvalidApply = 'invalidApply',\n  InvalidScreen = 'invalidScreen',\n  InvalidVariant = 'invalidVariant',\n  InvalidConfigPath = 'invalidConfigPath',\n  InvalidTailwindDirective = 'invalidTailwindDirective',\n  RecommendedVariantOrder = 'recommendedVariantOrder',\n}\n\nexport type CssConflictDiagnostic = Diagnostic & {\n  code: DiagnosticKind.CssConflict\n  className: DocumentClassName\n  otherClassNames: DocumentClassName[]\n}\n\nexport function isCssConflictDiagnostic(\n  diagnostic: AugmentedDiagnostic\n): diagnostic is CssConflictDiagnostic {\n  return diagnostic.code === DiagnosticKind.CssConflict\n}\n\nexport type InvalidApplyDiagnostic = Diagnostic & {\n  code: DiagnosticKind.InvalidApply\n  className: DocumentClassName\n}\n\nexport function isInvalidApplyDiagnostic(\n  diagnostic: AugmentedDiagnostic\n): diagnostic is InvalidApplyDiagnostic {\n  return diagnostic.code === DiagnosticKind.InvalidApply\n}\n\nexport type InvalidScreenDiagnostic = Diagnostic & {\n  code: DiagnosticKind.InvalidScreen\n  suggestions: string[]\n}\n\nexport function isInvalidScreenDiagnostic(\n  diagnostic: AugmentedDiagnostic\n): diagnostic is InvalidScreenDiagnostic {\n  return diagnostic.code === DiagnosticKind.InvalidScreen\n}\n\nexport type InvalidVariantDiagnostic = Diagnostic & {\n  code: DiagnosticKind.InvalidVariant\n  suggestions: string[]\n}\n\nexport function isInvalidVariantDiagnostic(\n  diagnostic: AugmentedDiagnostic\n): diagnostic is InvalidVariantDiagnostic {\n  return diagnostic.code === DiagnosticKind.InvalidVariant\n}\n\nexport type InvalidConfigPathDiagnostic = Diagnostic & {\n  code: DiagnosticKind.InvalidConfigPath\n  suggestions: string[]\n}\n\nexport function isInvalidConfigPathDiagnostic(\n  diagnostic: AugmentedDiagnostic\n): diagnostic is InvalidConfigPathDiagnostic {\n  return diagnostic.code === DiagnosticKind.InvalidConfigPath\n}\n\nexport type InvalidTailwindDirectiveDiagnostic = Diagnostic & {\n  code: DiagnosticKind.InvalidTailwindDirective\n  suggestions: string[]\n}\n\nexport function isInvalidTailwindDirectiveDiagnostic(\n  diagnostic: AugmentedDiagnostic\n): diagnostic is InvalidTailwindDirectiveDiagnostic {\n  return diagnostic.code === DiagnosticKind.InvalidTailwindDirective\n}\n\nexport type RecommendedVariantOrderDiagnostic = Diagnostic & {\n  code: DiagnosticKind.RecommendedVariantOrder\n  suggestions: string[]\n}\n\nexport function isRecommendedVariantOrderDiagnostic(\n  diagnostic: AugmentedDiagnostic\n): diagnostic is RecommendedVariantOrderDiagnostic {\n  return diagnostic.code === DiagnosticKind.RecommendedVariantOrder\n}\n\nexport type AugmentedDiagnostic =\n  | CssConflictDiagnostic\n  | InvalidApplyDiagnostic\n  | InvalidScreenDiagnostic\n  | InvalidVariantDiagnostic\n  | InvalidConfigPathDiagnostic\n  | InvalidTailwindDirectiveDiagnostic\n  | RecommendedVariantOrderDiagnostic\n","export function joinWithAnd(strings: string[]): string {\n  return strings.reduce((acc, cur, i) => {\n    if (i === 0) {\n      return cur\n    }\n    if (strings.length > 1 && i === strings.length - 1) {\n      return `${acc} and ${cur}`\n    }\n    return `${acc}, ${cur}`\n  }, '')\n}\n","import { State } from './state'\nimport { getClassNameParts } from './getClassNameAtPosition'\nimport removeMeta from './removeMeta'\nimport dlv from 'dlv'\n\nexport function getClassNameDecls(\n  state: State,\n  className: string\n): Record<string, string> | Record<string, string>[] | null {\n  const parts = getClassNameParts(state, className)\n  if (!parts) return null\n\n  const info = dlv(state.classNames.classNames, [...parts, '__info'])\n\n  if (Array.isArray(info)) {\n    return info.map(removeMeta)\n  }\n\n  return removeMeta(info)\n}\n","import { joinWithAnd } from '../util/joinWithAnd'\nimport { State, Settings } from '../util/state'\nimport type { TextDocument, DiagnosticSeverity } from 'vscode-languageserver'\nimport { CssConflictDiagnostic, DiagnosticKind } from './types'\nimport { findClassListsInDocument, getClassNamesInClassList } from '../util/find'\nimport { getClassNameDecls } from '../util/getClassNameDecls'\nimport { getClassNameMeta } from '../util/getClassNameMeta'\nimport { equal } from '../util/array'\nimport * as jit from '../util/jit'\n\nexport async function getCssConflictDiagnostics(\n  state: State,\n  document: TextDocument,\n  settings: Settings\n): Promise<CssConflictDiagnostic[]> {\n  let severity = settings.tailwindCSS.lint.cssConflict\n  if (severity === 'ignore') return []\n\n  let diagnostics: CssConflictDiagnostic[] = []\n  const classLists = await findClassListsInDocument(state, document)\n\n  classLists.forEach((classList) => {\n    const classNames = getClassNamesInClassList(classList)\n\n    classNames.forEach((className, index) => {\n      if (state.jit) {\n        let { rules } = jit.generateRules(state, [className.className])\n        if (rules.length === 0) {\n          return\n        }\n\n        let info: Array<{ context: string[]; properties: string[] }> = rules.map((rule) => {\n          let properties: string[] = []\n          rule.walkDecls(({ prop }) => {\n            properties.push(prop)\n          })\n          let context = jit.getRuleContext(state, rule, className.className)\n          return { context, properties }\n        })\n\n        let otherClassNames = classNames.filter((_className, i) => i !== index)\n\n        let conflictingClassNames = otherClassNames.filter((otherClassName) => {\n          let { rules: otherRules } = jit.generateRules(state, [otherClassName.className])\n          if (otherRules.length !== rules.length) {\n            return false\n          }\n\n          for (let i = 0; i < otherRules.length; i++) {\n            let rule = otherRules[i]\n            let properties: string[] = []\n            rule.walkDecls(({ prop }) => {\n              properties.push(prop)\n            })\n            if (!equal(info[i].properties, properties)) {\n              return false\n            }\n            let context = jit.getRuleContext(state, rule, otherClassName.className)\n            if (!equal(info[i].context, context)) {\n              return false\n            }\n          }\n\n          return true\n        })\n\n        if (conflictingClassNames.length === 0) return\n\n        diagnostics.push({\n          code: DiagnosticKind.CssConflict,\n          className,\n          otherClassNames: conflictingClassNames,\n          range: className.range,\n          severity:\n            severity === 'error'\n              ? 1 /* DiagnosticSeverity.Error */\n              : 2 /* DiagnosticSeverity.Warning */,\n          message: `'${className.className}' applies the same CSS properties as ${joinWithAnd(\n            conflictingClassNames.map(\n              (conflictingClassName) => `'${conflictingClassName.className}'`\n            )\n          )}.`,\n          relatedInformation: conflictingClassNames.map((conflictingClassName) => {\n            return {\n              message: conflictingClassName.className,\n              location: {\n                uri: document.uri,\n                range: conflictingClassName.range,\n              },\n            }\n          }),\n        })\n\n        return\n      }\n\n      let decls = getClassNameDecls(state, className.className)\n      if (!decls) return\n\n      let properties = Object.keys(decls)\n      let meta = getClassNameMeta(state, className.className)\n\n      let otherClassNames = classNames.filter((_className, i) => i !== index)\n\n      let conflictingClassNames = otherClassNames.filter((otherClassName) => {\n        let otherDecls = getClassNameDecls(state, otherClassName.className)\n        if (!otherDecls) return false\n\n        let otherMeta = getClassNameMeta(state, otherClassName.className)\n\n        return (\n          equal(properties, Object.keys(otherDecls)) &&\n          !Array.isArray(meta) &&\n          !Array.isArray(otherMeta) &&\n          equal(meta.context, otherMeta.context) &&\n          equal(meta.pseudo, otherMeta.pseudo) &&\n          meta.scope === otherMeta.scope\n        )\n      })\n\n      if (conflictingClassNames.length === 0) return\n\n      diagnostics.push({\n        code: DiagnosticKind.CssConflict,\n        className,\n        otherClassNames: conflictingClassNames,\n        range: className.range,\n        severity:\n          severity === 'error'\n            ? 1 /* DiagnosticSeverity.Error */\n            : 2 /* DiagnosticSeverity.Warning */,\n        message: `'${className.className}' applies the same CSS ${\n          properties.length === 1 ? 'property' : 'properties'\n        } as ${joinWithAnd(\n          conflictingClassNames.map((conflictingClassName) => `'${conflictingClassName.className}'`)\n        )}.`,\n        relatedInformation: conflictingClassNames.map((conflictingClassName) => {\n          return {\n            message: conflictingClassName.className,\n            location: {\n              uri: document.uri,\n              range: conflictingClassName.range,\n            },\n          }\n        }),\n      })\n    })\n  })\n\n  return diagnostics\n}\n","import { findClassNamesInRange } from '../util/find'\nimport { InvalidApplyDiagnostic, DiagnosticKind } from './types'\nimport { Settings, State } from '../util/state'\nimport type { TextDocument, DiagnosticSeverity } from 'vscode-languageserver'\nimport { validateApply } from '../util/validateApply'\n\nexport async function getInvalidApplyDiagnostics(\n  state: State,\n  document: TextDocument,\n  settings: Settings\n): Promise<InvalidApplyDiagnostic[]> {\n  let severity = settings.tailwindCSS.lint.invalidApply\n  if (severity === 'ignore') return []\n\n  const classNames = await findClassNamesInRange(state, document, undefined, 'css', false)\n\n  let diagnostics: InvalidApplyDiagnostic[] = classNames.map((className) => {\n    let result = validateApply(state, className.className)\n\n    if (result === null || result.isApplyable === true) {\n      return null\n    }\n\n    return {\n      code: DiagnosticKind.InvalidApply,\n      severity:\n        severity === 'error'\n          ? 1 /* DiagnosticSeverity.Error */\n          : 2 /* DiagnosticSeverity.Warning */,\n      range: className.range,\n      message: result.reason,\n      className,\n    }\n  })\n\n  return diagnostics.filter(Boolean)\n}\n","import sift from 'sift-string'\n\nexport function closest(input: string, options: string[]): string | undefined {\n  return options.concat([]).sort((a, b) => sift(input, a) - sift(input, b))[0]\n}\n","import type { Range } from 'vscode-languageserver'\n\nexport function absoluteRange(range: Range, reference?: Range) {\n  return {\n    start: {\n      line: (reference?.start.line || 0) + range.start.line,\n      character:\n        (range.end.line === 0 ? reference?.start.character || 0 : 0) +\n        range.start.character,\n    },\n    end: {\n      line: (reference?.start.line || 0) + range.end.line,\n      character:\n        (range.end.line === 0 ? reference?.start.character || 0 : 0) +\n        range.end.character,\n    },\n  }\n}\n","import { State, Settings } from '../util/state'\nimport type { TextDocument, Range, DiagnosticSeverity } from 'vscode-languageserver'\nimport { InvalidScreenDiagnostic, DiagnosticKind } from './types'\nimport { isCssDoc } from '../util/css'\nimport { getLanguageBoundaries } from '../util/getLanguageBoundaries'\nimport { findAll, indexToPosition } from '../util/find'\nimport { closest } from '../util/closest'\nimport { absoluteRange } from '../util/absoluteRange'\nimport dlv from 'dlv'\nimport { getTextWithoutComments } from '../util/doc'\n\nexport function getInvalidScreenDiagnostics(\n  state: State,\n  document: TextDocument,\n  settings: Settings\n): InvalidScreenDiagnostic[] {\n  let severity = settings.tailwindCSS.lint.invalidScreen\n  if (severity === 'ignore') return []\n\n  let diagnostics: InvalidScreenDiagnostic[] = []\n  let ranges: Range[] = []\n\n  if (isCssDoc(state, document)) {\n    ranges.push(undefined)\n  } else {\n    let boundaries = getLanguageBoundaries(state, document)\n    if (!boundaries) return []\n    ranges.push(...boundaries.filter((b) => b.type === 'css').map(({ range }) => range))\n  }\n\n  ranges.forEach((range) => {\n    let text = getTextWithoutComments(document, 'css', range)\n    let matches = findAll(/(?:\\s|^)@screen\\s+(?<screen>[^\\s{]+)/g, text)\n\n    matches.forEach((match) => {\n      if (state.screens.includes(match.groups.screen)) {\n        return null\n      }\n\n      let message = `The screen '${match.groups.screen}' does not exist in your theme config.`\n      let suggestions: string[] = []\n      let suggestion = closest(match.groups.screen, state.screens)\n\n      if (suggestion) {\n        suggestions.push(suggestion)\n        message += ` Did you mean '${suggestion}'?`\n      }\n\n      diagnostics.push({\n        code: DiagnosticKind.InvalidScreen,\n        range: absoluteRange(\n          {\n            start: indexToPosition(\n              text,\n              match.index + match[0].length - match.groups.screen.length\n            ),\n            end: indexToPosition(text, match.index + match[0].length),\n          },\n          range\n        ),\n        severity:\n          severity === 'error'\n            ? 1 /* DiagnosticSeverity.Error */\n            : 2 /* DiagnosticSeverity.Warning */,\n        message,\n        suggestions,\n      })\n    })\n  })\n\n  return diagnostics\n}\n","import { State, Settings } from '../util/state'\nimport type { TextDocument, Range, DiagnosticSeverity } from 'vscode-languageserver'\nimport { InvalidVariantDiagnostic, DiagnosticKind } from './types'\nimport { isCssDoc } from '../util/css'\nimport { getLanguageBoundaries } from '../util/getLanguageBoundaries'\nimport { findAll, indexToPosition } from '../util/find'\nimport { closest } from '../util/closest'\nimport { absoluteRange } from '../util/absoluteRange'\nimport * as semver from '../util/semver'\nimport { getTextWithoutComments } from '../util/doc'\n\nexport function getInvalidVariantDiagnostics(\n  state: State,\n  document: TextDocument,\n  settings: Settings\n): InvalidVariantDiagnostic[] {\n  let severity = settings.tailwindCSS.lint.invalidVariant\n  if (severity === 'ignore') return []\n\n  if (semver.gte(state.version, '2.99.0')) {\n    return []\n  }\n\n  let diagnostics: InvalidVariantDiagnostic[] = []\n  let ranges: Range[] = []\n\n  if (isCssDoc(state, document)) {\n    ranges.push(undefined)\n  } else {\n    let boundaries = getLanguageBoundaries(state, document)\n    if (!boundaries) return []\n    ranges.push(...boundaries.filter((b) => b.type === 'css').map(({ range }) => range))\n  }\n\n  let possibleVariants = state.variants.flatMap((variant) => {\n    if (variant.values.length) {\n      return variant.values.map((value) =>\n        value === 'DEFAULT' ? variant.name : `${variant.name}${variant.hasDash ? '-' : ''}${value}`\n      )\n    }\n    return [variant.name]\n  })\n  if (state.jit) {\n    possibleVariants.unshift('responsive')\n    possibleVariants = possibleVariants.filter((v) => !state.screens.includes(v))\n  }\n\n  ranges.forEach((range) => {\n    let text = getTextWithoutComments(document, 'css', range)\n    let matches = findAll(/(?:\\s|^)@variants\\s+(?<variants>[^{]+)/g, text)\n\n    matches.forEach((match) => {\n      let variants = match.groups.variants.split(/(\\s*,\\s*)/)\n      let listStartIndex = match.index + match[0].length - match.groups.variants.length\n\n      for (let i = 0; i < variants.length; i += 2) {\n        let variant = variants[i].trim()\n        if (possibleVariants.includes(variant)) {\n          continue\n        }\n\n        let message = `The variant '${variant}' does not exist.`\n        let suggestions: string[] = []\n        let suggestion = closest(variant, possibleVariants)\n\n        if (suggestion) {\n          suggestions.push(suggestion)\n          message += ` Did you mean '${suggestion}'?`\n        }\n\n        let variantStartIndex = listStartIndex + variants.slice(0, i).join('').length\n\n        diagnostics.push({\n          code: DiagnosticKind.InvalidVariant,\n          range: absoluteRange(\n            {\n              start: indexToPosition(text, variantStartIndex),\n              end: indexToPosition(text, variantStartIndex + variant.length),\n            },\n            range\n          ),\n          severity:\n            severity === 'error'\n              ? 1 /* DiagnosticSeverity.Error */\n              : 2 /* DiagnosticSeverity.Warning */,\n          message,\n          suggestions,\n        })\n      }\n    })\n  })\n\n  return diagnostics\n}\n","// https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L6735-L6744\nlet rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g\nlet reEscapeChar = /\\\\(\\\\)?/g\n\nexport function stringToPath(string: string): string[] {\n  let result: string[] = []\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('')\n  }\n  // @ts-ignore\n  string.replace(rePropName, (match, number, quote, subString) => {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match)\n  })\n  return result\n}\n","import { State, Settings } from '../util/state'\nimport type { TextDocument } from 'vscode-languageserver'\nimport { InvalidConfigPathDiagnostic, DiagnosticKind } from './types'\nimport { findHelperFunctionsInDocument } from '../util/find'\nimport { stringToPath } from '../util/stringToPath'\nimport isObject from '../util/isObject'\nimport { closest } from '../util/closest'\nimport { combinations } from '../util/combinations'\nimport dlv from 'dlv'\n\nfunction pathToString(path: string | string[]): string {\n  if (typeof path === 'string') return path\n  return path.reduce((acc, cur, i) => {\n    if (i === 0) return cur\n    if (cur.includes('.')) return `${acc}[${cur}]`\n    return `${acc}.${cur}`\n  }, '')\n}\n\nexport function validateConfigPath(\n  state: State,\n  path: string | string[],\n  base: string[] = []\n): { isValid: true; value: any } | { isValid: false; reason: string; suggestions: string[] } {\n  let keys = Array.isArray(path) ? path : stringToPath(path)\n  let value = dlv(state.config, [...base, ...keys])\n  let suggestions: string[] = []\n\n  function findAlternativePath(): string[] {\n    let points = combinations('123456789'.substr(0, keys.length - 1)).map((x) =>\n      x.split('').map((x) => parseInt(x, 10))\n    )\n\n    let possibilities: string[][] = points\n      .map((p) => {\n        let result = []\n        let i = 0\n        p.forEach((x) => {\n          result.push(keys.slice(i, x).join('.'))\n          i = x\n        })\n        result.push(keys.slice(i).join('.'))\n        return result\n      })\n      .slice(1) // skip original path\n\n    return possibilities.find((possibility) => validateConfigPath(state, possibility, base).isValid)\n  }\n\n  if (typeof value === 'undefined') {\n    let reason = `'${pathToString(path)}' does not exist in your theme config.`\n    let parentPath = [...base, ...keys.slice(0, keys.length - 1)]\n    let parentValue = dlv(state.config, parentPath)\n\n    if (isObject(parentValue)) {\n      let closestValidKey = closest(\n        keys[keys.length - 1],\n        Object.keys(parentValue).filter(\n          (key) => validateConfigPath(state, [...parentPath, key]).isValid\n        )\n      )\n      if (closestValidKey) {\n        suggestions.push(pathToString([...keys.slice(0, keys.length - 1), closestValidKey]))\n        reason += ` Did you mean '${suggestions[0]}'?`\n      }\n    } else {\n      let altPath = findAlternativePath()\n      if (altPath) {\n        return {\n          isValid: false,\n          reason: `${reason} Did you mean '${pathToString(altPath)}'?`,\n          suggestions: [pathToString(altPath)],\n        }\n      }\n    }\n\n    return {\n      isValid: false,\n      reason,\n      suggestions,\n    }\n  }\n\n  if (\n    !(\n      typeof value === 'string' ||\n      typeof value === 'number' ||\n      value instanceof String ||\n      value instanceof Number ||\n      Array.isArray(value) ||\n      typeof value === 'function'\n    )\n  ) {\n    let reason = `'${pathToString(path)}' was found but does not resolve to a valid theme value.`\n\n    if (isObject(value)) {\n      let validKeys = Object.keys(value).filter(\n        (key) => validateConfigPath(state, [...keys, key], base).isValid\n      )\n      if (validKeys.length) {\n        suggestions.push(...validKeys.map((validKey) => pathToString([...keys, validKey])))\n        reason += ` Did you mean something like '${suggestions[0]}'?`\n      }\n    }\n    return {\n      isValid: false,\n      reason,\n      suggestions,\n    }\n  }\n\n  // The value resolves successfully, but we need to check that there\n  // wasn't any funny business. If you have a theme object:\n  // { msg: 'hello' } and do theme('msg.0')\n  // this will resolve to 'h', which is probably not intentional, so we\n  // check that all of the keys are object or array keys (i.e. not string\n  // indexes)\n  let isValid = true\n  for (let i = keys.length - 1; i >= 0; i--) {\n    let key = keys[i]\n    let parentValue = dlv(state.config, [...base, ...keys.slice(0, i)])\n    if (/^[0-9]+$/.test(key)) {\n      if (!isObject(parentValue) && !Array.isArray(parentValue)) {\n        isValid = false\n        break\n      }\n    } else if (!isObject(parentValue)) {\n      isValid = false\n      break\n    }\n  }\n  if (!isValid) {\n    let reason = `'${pathToString(path)}' does not exist in your theme config.`\n\n    let altPath = findAlternativePath()\n    if (altPath) {\n      return {\n        isValid: false,\n        reason: `${reason} Did you mean '${pathToString(altPath)}'?`,\n        suggestions: [pathToString(altPath)],\n      }\n    }\n\n    return {\n      isValid: false,\n      reason,\n      suggestions: [],\n    }\n  }\n\n  return {\n    isValid: true,\n    value,\n  }\n}\n\nexport function getInvalidConfigPathDiagnostics(\n  state: State,\n  document: TextDocument,\n  settings: Settings\n): InvalidConfigPathDiagnostic[] {\n  let severity = settings.tailwindCSS.lint.invalidConfigPath\n  if (severity === 'ignore') return []\n\n  let diagnostics: InvalidConfigPathDiagnostic[] = []\n\n  findHelperFunctionsInDocument(state, document).forEach((helperFn) => {\n    let base = helperFn.helper === 'theme' ? ['theme'] : []\n    let result = validateConfigPath(state, helperFn.path, base)\n\n    if (result.isValid === true) {\n      return\n    }\n\n    diagnostics.push({\n      code: DiagnosticKind.InvalidConfigPath,\n      range: helperFn.ranges.path,\n      severity:\n        severity === 'error'\n          ? 1 /* DiagnosticSeverity.Error */\n          : 2 /* DiagnosticSeverity.Warning */,\n      message: result.reason,\n      suggestions: result.suggestions,\n    })\n  })\n\n  return diagnostics\n}\n","import { State, Settings } from '../util/state'\nimport type { TextDocument, Range, DiagnosticSeverity } from 'vscode-languageserver'\nimport { InvalidTailwindDirectiveDiagnostic, DiagnosticKind } from './types'\nimport { isCssDoc } from '../util/css'\nimport { getLanguageBoundaries } from '../util/getLanguageBoundaries'\nimport { findAll, indexToPosition } from '../util/find'\nimport * as semver from '../util/semver'\nimport { closest } from '../util/closest'\nimport { absoluteRange } from '../util/absoluteRange'\nimport { getTextWithoutComments } from '../util/doc'\n\nexport function getInvalidTailwindDirectiveDiagnostics(\n  state: State,\n  document: TextDocument,\n  settings: Settings\n): InvalidTailwindDirectiveDiagnostic[] {\n  let severity = settings.tailwindCSS.lint.invalidTailwindDirective\n  if (severity === 'ignore') return []\n\n  let diagnostics: InvalidTailwindDirectiveDiagnostic[] = []\n  let ranges: Range[] = []\n\n  if (isCssDoc(state, document)) {\n    ranges.push(undefined)\n  } else {\n    let boundaries = getLanguageBoundaries(state, document)\n    if (!boundaries) return []\n    ranges.push(...boundaries.filter((b) => b.type === 'css').map(({ range }) => range))\n  }\n\n  let notSemicolonLanguages = ['sass', 'sugarss', 'stylus']\n  let regex: RegExp\n  if (\n    notSemicolonLanguages.includes(document.languageId) ||\n    (state.editor &&\n      notSemicolonLanguages.includes(state.editor.userLanguages[document.languageId]))\n  ) {\n    regex = /(?:\\s|^)@tailwind\\s+(?<value>[^\\r\\n]+)/g\n  } else {\n    regex = /(?:\\s|^)@tailwind\\s+(?<value>[^;]+)/g\n  }\n\n  let hasVariantsDirective = state.jit && semver.gte(state.version, '2.1.99')\n\n  ranges.forEach((range) => {\n    let text = getTextWithoutComments(document, 'css', range)\n    let matches = findAll(regex, text)\n\n    let valid = [\n      'utilities',\n      'components',\n      'screens',\n      semver.gte(state.version, '1.0.0-beta.1') ? 'base' : 'preflight',\n      hasVariantsDirective && 'variants',\n    ].filter(Boolean)\n\n    let suggestable = valid\n\n    if (hasVariantsDirective) {\n      // Don't suggest `screens`, because it's deprecated\n      suggestable = suggestable.filter((value) => value !== 'screens')\n    }\n\n    matches.forEach((match) => {\n      if (valid.includes(match.groups.value)) {\n        return null\n      }\n\n      let message = `'${match.groups.value}' is not a valid value.`\n      let suggestions: string[] = []\n\n      if (match.groups.value === 'preflight') {\n        suggestions.push('base')\n        message += ` Did you mean 'base'?`\n      } else {\n        let suggestion = closest(match.groups.value, suggestable)\n        if (suggestion) {\n          suggestions.push(suggestion)\n          message += ` Did you mean '${suggestion}'?`\n        }\n      }\n\n      diagnostics.push({\n        code: DiagnosticKind.InvalidTailwindDirective,\n        range: absoluteRange(\n          {\n            start: indexToPosition(text, match.index + match[0].length - match.groups.value.length),\n            end: indexToPosition(text, match.index + match[0].length),\n          },\n          range\n        ),\n        severity:\n          severity === 'error'\n            ? 1 /* DiagnosticSeverity.Error */\n            : 2 /* DiagnosticSeverity.Warning */,\n        message,\n        suggestions,\n      })\n    })\n  })\n\n  return diagnostics\n}\n","import { State, Settings } from '../util/state'\nimport type { TextDocument } from 'vscode-languageserver'\nimport { RecommendedVariantOrderDiagnostic, DiagnosticKind } from './types'\nimport { findClassListsInDocument, getClassNamesInClassList } from '../util/find'\nimport * as jit from '../util/jit'\nimport { getVariantsFromClassName } from '../util/getVariantsFromClassName'\nimport { equalExact } from '../util/array'\nimport * as semver from '../util/semver'\n\nexport async function getRecommendedVariantOrderDiagnostics(\n  state: State,\n  document: TextDocument,\n  settings: Settings\n): Promise<RecommendedVariantOrderDiagnostic[]> {\n  if (!state.jit) return []\n\n  if (semver.gte(state.version, '2.99.0')) return []\n\n  let severity = settings.tailwindCSS.lint.recommendedVariantOrder\n  if (severity === 'ignore') return []\n\n  let diagnostics: RecommendedVariantOrderDiagnostic[] = []\n  const classLists = await findClassListsInDocument(state, document)\n\n  classLists.forEach((classList) => {\n    const classNames = getClassNamesInClassList(classList)\n    classNames.forEach((className) => {\n      let { rules } = jit.generateRules(state, [className.className])\n      if (rules.length === 0) {\n        return\n      }\n\n      let { variants, offset } = getVariantsFromClassName(state, className.className)\n      let sortedVariants = [...variants].sort((a, b) =>\n        jit.bigSign(state.jitContext.variantOrder.get(b) - state.jitContext.variantOrder.get(a))\n      )\n\n      if (!equalExact(variants, sortedVariants)) {\n        diagnostics.push({\n          code: DiagnosticKind.RecommendedVariantOrder,\n          suggestions: [\n            [...sortedVariants, className.className.substr(offset)].join(state.separator),\n          ],\n          range: className.range,\n          severity:\n            severity === 'error'\n              ? 1 /* DiagnosticSeverity.Error */\n              : 2 /* DiagnosticSeverity.Warning */,\n          message:\n            'Variants are not in the recommended order, which may cause unexpected CSS output.',\n        })\n      }\n    })\n  })\n\n  return diagnostics\n}\n","import type { TextDocument } from 'vscode-languageserver'\nimport { State } from '../util/state'\nimport { DiagnosticKind, AugmentedDiagnostic } from './types'\nimport { getCssConflictDiagnostics } from './getCssConflictDiagnostics'\nimport { getInvalidApplyDiagnostics } from './getInvalidApplyDiagnostics'\nimport { getInvalidScreenDiagnostics } from './getInvalidScreenDiagnostics'\nimport { getInvalidVariantDiagnostics } from './getInvalidVariantDiagnostics'\nimport { getInvalidConfigPathDiagnostics } from './getInvalidConfigPathDiagnostics'\nimport { getInvalidTailwindDirectiveDiagnostics } from './getInvalidTailwindDirectiveDiagnostics'\nimport { getRecommendedVariantOrderDiagnostics } from './getRecommendedVariantOrderDiagnostics'\n\nexport async function doValidate(\n  state: State,\n  document: TextDocument,\n  only: DiagnosticKind[] = [\n    DiagnosticKind.CssConflict,\n    DiagnosticKind.InvalidApply,\n    DiagnosticKind.InvalidScreen,\n    DiagnosticKind.InvalidVariant,\n    DiagnosticKind.InvalidConfigPath,\n    DiagnosticKind.InvalidTailwindDirective,\n    DiagnosticKind.RecommendedVariantOrder,\n  ]\n): Promise<AugmentedDiagnostic[]> {\n  const settings = await state.editor.getConfiguration(document.uri)\n\n  return settings.tailwindCSS.validate\n    ? [\n        ...(only.includes(DiagnosticKind.CssConflict)\n          ? await getCssConflictDiagnostics(state, document, settings)\n          : []),\n        ...(only.includes(DiagnosticKind.InvalidApply)\n          ? await getInvalidApplyDiagnostics(state, document, settings)\n          : []),\n        ...(only.includes(DiagnosticKind.InvalidScreen)\n          ? getInvalidScreenDiagnostics(state, document, settings)\n          : []),\n        ...(only.includes(DiagnosticKind.InvalidVariant)\n          ? getInvalidVariantDiagnostics(state, document, settings)\n          : []),\n        ...(only.includes(DiagnosticKind.InvalidConfigPath)\n          ? getInvalidConfigPathDiagnostics(state, document, settings)\n          : []),\n        ...(only.includes(DiagnosticKind.InvalidTailwindDirective)\n          ? getInvalidTailwindDirectiveDiagnostics(state, document, settings)\n          : []),\n        ...(only.includes(DiagnosticKind.RecommendedVariantOrder)\n          ? await getRecommendedVariantOrderDiagnostics(state, document, settings)\n          : []),\n      ]\n    : []\n}\n","import { Range } from 'vscode-languageserver'\nimport lineColumn from 'line-column'\nimport { ensureArray } from './array'\n\nexport function removeRangesFromString(\n  str: string,\n  rangeOrRanges: Range | Range[]\n): string {\n  let ranges = ensureArray(rangeOrRanges)\n  let finder = lineColumn(str + '\\n', { origin: 0 })\n  let indexRanges: { start: number; end: number }[] = []\n\n  ranges.forEach((range) => {\n    let start = finder.toIndex(range.start.line, range.start.character)\n    let end = finder.toIndex(range.end.line, range.end.character)\n    for (let i = start - 1; i >= 0; i--) {\n      if (/\\s/.test(str.charAt(i))) {\n        start = i\n      } else {\n        break\n      }\n    }\n    indexRanges.push({ start, end })\n  })\n\n  indexRanges.sort((a, b) => a.start - b.start)\n\n  let result = ''\n  let i = 0\n\n  indexRanges.forEach((indexRange) => {\n    result += str.substring(i, indexRange.start)\n    i = indexRange.end\n  })\n\n  result += str.substring(i)\n\n  return result.trim()\n}\n","/*\nThis is a modified version of the postcss-js 'parse' function which accepts the\npostcss module as an argument. License below:\n\nThe MIT License (MIT)\n\nCopyright 2015 Andrey Sitnik <andrey@sitnik.ru>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvar IMPORTANT = /\\s*!important\\s*$/i\n\nvar unitless = {\n  'box-flex': true,\n  'box-flex-group': true,\n  'column-count': true,\n  flex: true,\n  'flex-grow': true,\n  'flex-positive': true,\n  'flex-shrink': true,\n  'flex-negative': true,\n  'font-weight': true,\n  'line-clamp': true,\n  'line-height': true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  'tab-size': true,\n  widows: true,\n  'z-index': true,\n  zoom: true,\n  'fill-opacity': true,\n  'stroke-dashoffset': true,\n  'stroke-opacity': true,\n  'stroke-width': true,\n}\n\nfunction dashify(str) {\n  return str\n    .replace(/([A-Z])/g, '-$1')\n    .replace(/^ms-/, '-ms-')\n    .toLowerCase()\n}\n\nfunction decl(parent, name, value, postcss) {\n  if (value === false || value === null) return\n\n  name = dashify(name)\n  if (typeof value === 'number') {\n    if (value === 0 || unitless[name]) {\n      value = value.toString()\n    } else {\n      value = value.toString() + 'px'\n    }\n  }\n\n  if (name === 'css-float') name = 'float'\n\n  if (IMPORTANT.test(value)) {\n    value = value.replace(IMPORTANT, '')\n    parent.push(postcss.decl({ prop: name, value: value, important: true }))\n  } else {\n    parent.push(postcss.decl({ prop: name, value: value }))\n  }\n}\n\nfunction atRule(parent, parts, value, postcss) {\n  var node = postcss.atRule({ name: parts[1], params: parts[3] || '' })\n  if (typeof value === 'object') {\n    node.nodes = []\n    parse(value, node, postcss)\n  }\n  parent.push(node)\n}\n\nfunction parse(obj, parent, postcss) {\n  var name, value, node, i\n  for (name in obj) {\n    if (obj.hasOwnProperty(name)) {\n      value = obj[name]\n      if (value === null || typeof value === 'undefined') {\n        continue\n      } else if (name[0] === '@') {\n        var parts = name.match(/@([^\\s]+)(\\s+([\\w\\W]*)\\s*)?/)\n        if (Array.isArray(value)) {\n          for (i = 0; i < value.length; i++) {\n            atRule(parent, parts, value[i], postcss)\n          }\n        } else {\n          atRule(parent, parts, value, postcss)\n        }\n      } else if (Array.isArray(value)) {\n        for (i = 0; i < value.length; i++) {\n          decl(parent, name, value[i], postcss)\n        }\n      } else if (typeof value === 'object') {\n        node = postcss.rule({ selector: name })\n        parse(value, node, postcss)\n        parent.push(node)\n      } else {\n        decl(parent, name, value, postcss)\n      }\n    }\n  }\n}\n\nexport function cssObjToAst(obj, postcss) {\n  var root = postcss.root()\n  parse(obj, root, postcss)\n  return root\n}\n","import type { CodeAction, CodeActionParams, TextEdit, Range } from 'vscode-languageserver'\nimport { State } from '../util/state'\nimport { InvalidApplyDiagnostic } from '../diagnostics/types'\nimport { isCssDoc } from '../util/css'\nimport { getLanguageBoundaries } from '../util/getLanguageBoundaries'\nimport { getClassNameMeta } from '../util/getClassNameMeta'\nimport { getClassNameParts } from '../util/getClassNameAtPosition'\nimport { validateApply } from '../util/validateApply'\nimport { isWithinRange } from '../util/isWithinRange'\nimport dlv from 'dlv'\nimport type { Root, Source } from 'postcss'\nimport { absoluteRange } from '../util/absoluteRange'\nimport { removeRangesFromString } from '../util/removeRangesFromString'\nimport detectIndent from 'detect-indent'\nimport isObject from '../util/isObject'\nimport { cssObjToAst } from '../util/cssObjToAst'\nimport { dset } from 'dset'\nimport selectorParser from 'postcss-selector-parser'\nimport { flatten } from '../util/array'\nimport { getTextWithoutComments } from '../util/doc'\n\nexport async function provideInvalidApplyCodeActions(\n  state: State,\n  params: CodeActionParams,\n  diagnostic: InvalidApplyDiagnostic\n): Promise<CodeAction[]> {\n  let document = state.editor.documents.get(params.textDocument.uri)\n  if (!document) return []\n  let documentText = getTextWithoutComments(document, 'css')\n  let cssRange: Range\n  let cssText = documentText\n  const { postcss } = state.modules\n  let changes: TextEdit[] = []\n\n  let totalClassNamesInClassList = diagnostic.className.classList.classList.split(/\\s+/).length\n\n  let className = diagnostic.className.className\n  let classNameParts = getClassNameParts(state, className)\n  let classNameInfo = dlv(state.classNames.classNames, classNameParts)\n\n  if (Array.isArray(classNameInfo)) {\n    return []\n  }\n\n  if (!isCssDoc(state, document)) {\n    let languageBoundaries = getLanguageBoundaries(state, document)\n    if (!languageBoundaries) return []\n    cssRange = languageBoundaries\n      .filter((b) => b.type === 'css')\n      .find(({ range }) => isWithinRange(diagnostic.range.start, range))?.range\n    if (!cssRange) return []\n    cssText = getTextWithoutComments(document, 'css', cssRange)\n  }\n\n  try {\n    await postcss\n      .module([\n        // TODO: use plain function?\n        // @ts-ignore\n        postcss.module.plugin('', (_options = {}) => {\n          return (root: Root) => {\n            root.walkRules((rule) => {\n              if (changes.length) return false\n\n              rule.walkAtRules('apply', (atRule) => {\n                let atRuleRange = postcssSourceToRange(atRule.source)\n                if (cssRange) {\n                  atRuleRange = absoluteRange(atRuleRange, cssRange)\n                }\n\n                if (!isWithinRange(diagnostic.range.start, atRuleRange)) return undefined // true\n\n                let ast = classNameToAst(\n                  state,\n                  classNameParts,\n                  rule.selector,\n                  diagnostic.className.classList.important\n                )\n\n                if (!ast) return false\n\n                rule.after(ast.nodes)\n                let insertedRule = rule.next()\n                if (!insertedRule) return false\n\n                if (totalClassNamesInClassList === 1) {\n                  atRule.remove()\n                } else {\n                  changes.push({\n                    range: diagnostic.className.classList.range,\n                    newText: removeRangesFromString(\n                      diagnostic.className.classList.classList,\n                      diagnostic.className.relativeRange\n                    ),\n                  })\n                }\n\n                let ruleRange = postcssSourceToRange(rule.source)\n                if (cssRange) {\n                  ruleRange = absoluteRange(ruleRange, cssRange)\n                }\n\n                let outputIndent: string\n                let documentIndent = detectIndent(cssText)\n\n                changes.push({\n                  range: ruleRange,\n                  newText:\n                    rule.toString() +\n                    (insertedRule.raws.before || '\\n\\n') +\n                    insertedRule\n                      .toString()\n                      .replace(/\\n\\s*\\n/g, '\\n')\n                      .replace(/(@apply [^;\\n]+)$/gm, '$1;')\n                      .replace(/([^\\s^]){$/gm, '$1 {')\n                      .replace(/^\\s+/gm, (m: string) => {\n                        if (typeof outputIndent === 'undefined') outputIndent = m\n                        return m.replace(new RegExp(outputIndent, 'g'), documentIndent.indent)\n                      })\n                      .replace(/^(\\s+)(.*?[^{}]\\n)([^\\s}])/gm, '$1$2$1$3'),\n                })\n\n                return false\n              })\n\n              return undefined // true\n            })\n          }\n        }),\n      ])\n      .process(cssText, { from: undefined })\n  } catch (_) {\n    return []\n  }\n\n  if (!changes.length) {\n    return []\n  }\n\n  return [\n    {\n      title: 'Extract to new rule',\n      kind: 'quickfix', // CodeActionKind.QuickFix,\n      diagnostics: [diagnostic],\n      edit: {\n        changes: {\n          [params.textDocument.uri]: changes,\n        },\n      },\n    },\n  ]\n}\n\nfunction postcssSourceToRange(source: Source): Range {\n  return {\n    start: {\n      line: source.start.line - 1,\n      character: source.start.column - 1,\n    },\n    end: {\n      line: source.end.line - 1,\n      character: source.end.column,\n    },\n  }\n}\n\nfunction classNameToAst(\n  state: State,\n  classNameParts: string[],\n  selector: string,\n  important: boolean = false\n) {\n  const baseClassName = classNameParts[classNameParts.length - 1]\n  const validatedBaseClassName = validateApply(state, [baseClassName])\n  if (validatedBaseClassName === null || validatedBaseClassName.isApplyable === false) {\n    return null\n  }\n  const meta = getClassNameMeta(state, classNameParts)\n  if (Array.isArray(meta)) return null\n  let context = meta.context\n  let pseudo = meta.pseudo\n  const globalContexts = state.classNames.context\n  const path = []\n\n  for (let i = 0; i < classNameParts.length - 1; i++) {\n    let part = classNameParts[i]\n    let common = globalContexts[part]\n    if (!common) return null\n    if (state.screens.includes(part)) {\n      path.push(`@screen ${part}`)\n      context = context.filter((con) => !common.includes(con))\n    }\n  }\n\n  path.push(...context)\n\n  let obj = {}\n  for (let i = 1; i <= path.length; i++) {\n    dset(obj, path.slice(0, i), {})\n  }\n\n  selector = appendPseudosToSelector(selector, pseudo)\n  if (selector === null) return null\n\n  let rule = {\n    [selector]: {\n      [`@apply ${baseClassName}${important ? ' !important' : ''}`]: '',\n    },\n  }\n  if (path.length) {\n    dset(obj, path, rule)\n  } else {\n    obj = rule\n  }\n\n  return cssObjToAst(obj, state.modules.postcss)\n}\n\nfunction appendPseudosToSelector(selector: string, pseudos: string[]): string | null {\n  if (pseudos.length === 0) return selector\n\n  let canTransform = true\n\n  let transformedSelector = selectorParser((selectors) => {\n    flatten(selectors.split((_) => true)).forEach((sel) => {\n      // @ts-ignore\n      for (let i = sel.nodes.length - 1; i >= 0; i--) {\n        // @ts-ignore\n        if (sel.nodes[i].type !== 'pseudo') {\n          break\n          // @ts-ignore\n        } else if (pseudos.includes(sel.nodes[i].value)) {\n          canTransform = false\n          break\n        }\n      }\n      if (canTransform) {\n        pseudos.forEach((p) => {\n          // @ts-ignore\n          sel.append(selectorParser.pseudo({ value: p }))\n        })\n      }\n    })\n  }).processSync(selector)\n\n  if (!canTransform) return null\n\n  return transformedSelector\n}\n","import type { CodeAction, CodeActionParams } from 'vscode-languageserver'\nimport { State } from '../util/state'\nimport { doValidate } from '../diagnostics/diagnosticsProvider'\nimport { rangesEqual } from '../util/rangesEqual'\nimport {\n  DiagnosticKind,\n  isInvalidApplyDiagnostic,\n  AugmentedDiagnostic,\n  isCssConflictDiagnostic,\n  isInvalidConfigPathDiagnostic,\n  isInvalidTailwindDirectiveDiagnostic,\n  isInvalidScreenDiagnostic,\n  isInvalidVariantDiagnostic,\n  isRecommendedVariantOrderDiagnostic,\n} from '../diagnostics/types'\nimport { flatten, dedupeBy } from '../util/array'\nimport { provideCssConflictCodeActions } from './provideCssConflictCodeActions'\nimport { provideInvalidApplyCodeActions } from './provideInvalidApplyCodeActions'\nimport { provideSuggestionCodeActions } from './provideSuggestionCodeActions'\n\nasync function getDiagnosticsFromCodeActionParams(\n  state: State,\n  params: CodeActionParams,\n  only?: DiagnosticKind[]\n): Promise<AugmentedDiagnostic[]> {\n  let document = state.editor.documents.get(params.textDocument.uri)\n  if (!document) return []\n  let diagnostics = await doValidate(state, document, only)\n\n  return params.context.diagnostics\n    .map((diagnostic) => {\n      return diagnostics.find((d) => {\n        return (\n          d.code === diagnostic.code &&\n          d.message === diagnostic.message &&\n          rangesEqual(d.range, diagnostic.range)\n        )\n      })\n    })\n    .filter(Boolean)\n}\n\nexport async function doCodeActions(state: State, params: CodeActionParams): Promise<CodeAction[]> {\n  if (!state.enabled) {\n    return []\n  }\n\n  let diagnostics = await getDiagnosticsFromCodeActionParams(\n    state,\n    params,\n    params.context.diagnostics\n      .map((diagnostic) => diagnostic.code)\n      .filter(Boolean) as DiagnosticKind[]\n  )\n\n  return Promise.all(\n    diagnostics.map((diagnostic) => {\n      if (isInvalidApplyDiagnostic(diagnostic)) {\n        return provideInvalidApplyCodeActions(state, params, diagnostic)\n      }\n\n      if (isCssConflictDiagnostic(diagnostic)) {\n        return provideCssConflictCodeActions(state, params, diagnostic)\n      }\n\n      if (\n        isInvalidConfigPathDiagnostic(diagnostic) ||\n        isInvalidTailwindDirectiveDiagnostic(diagnostic) ||\n        isInvalidScreenDiagnostic(diagnostic) ||\n        isInvalidVariantDiagnostic(diagnostic) ||\n        isRecommendedVariantOrderDiagnostic(diagnostic)\n      ) {\n        return provideSuggestionCodeActions(state, params, diagnostic)\n      }\n\n      return []\n    })\n  )\n    .then(flatten)\n    .then((x) => dedupeBy(x, (item) => JSON.stringify(item.edit)))\n}\n","import { State } from '../util/state'\nimport type {\n  CodeActionParams,\n  CodeAction,\n} from 'vscode-languageserver'\nimport { CssConflictDiagnostic } from '../diagnostics/types'\nimport { joinWithAnd } from '../util/joinWithAnd'\nimport { removeRangesFromString } from '../util/removeRangesFromString'\n\nexport async function provideCssConflictCodeActions(\n  _state: State,\n  params: CodeActionParams,\n  diagnostic: CssConflictDiagnostic\n): Promise<CodeAction[]> {\n  return [\n    {\n      title: `Delete ${joinWithAnd(\n        diagnostic.otherClassNames.map(\n          (otherClassName) => `'${otherClassName.className}'`\n        )\n      )}`,\n      kind: 'quickfix', // CodeActionKind.QuickFix,\n      diagnostics: [diagnostic],\n      edit: {\n        changes: {\n          [params.textDocument.uri]: [\n            {\n              range: diagnostic.className.classList.range,\n              newText: removeRangesFromString(\n                diagnostic.className.classList.classList,\n                diagnostic.otherClassNames.map(\n                  (otherClassName) => otherClassName.relativeRange\n                )\n              ),\n            },\n          ],\n        },\n      },\n    },\n  ]\n}\n","import { State } from '../util/state'\nimport type { CodeActionParams, CodeAction } from 'vscode-languageserver'\nimport {\n  InvalidConfigPathDiagnostic,\n  InvalidTailwindDirectiveDiagnostic,\n  InvalidScreenDiagnostic,\n  InvalidVariantDiagnostic,\n  RecommendedVariantOrderDiagnostic,\n} from '../diagnostics/types'\n\nexport function provideSuggestionCodeActions(\n  _state: State,\n  params: CodeActionParams,\n  diagnostic:\n    | InvalidConfigPathDiagnostic\n    | InvalidTailwindDirectiveDiagnostic\n    | InvalidScreenDiagnostic\n    | InvalidVariantDiagnostic\n    | RecommendedVariantOrderDiagnostic\n): CodeAction[] {\n  return diagnostic.suggestions.map((suggestion) => ({\n    title: `Replace with '${suggestion}'`,\n    kind: 'quickfix', // CodeActionKind.QuickFix,\n    diagnostics: [diagnostic],\n    edit: {\n      changes: {\n        [params.textDocument.uri]: [\n          {\n            range: diagnostic.range,\n            newText: suggestion,\n          },\n        ],\n      },\n    },\n  }))\n}\n","import type { TextDocument, Range, Position } from 'vscode-languageserver'\n\nexport function isValidLocationForEmmetAbbreviation(\n  document: TextDocument,\n  abbreviationRange: Range\n): boolean {\n  const startAngle = '<'\n  const endAngle = '>'\n  const escape = '\\\\'\n  const question = '?'\n  let start: Position = { line: 0, character: 0 }\n\n  let textToBackTrack = document.getText({\n    start: {\n      line: start.line,\n      character: start.character,\n    },\n    end: {\n      line: abbreviationRange.start.line,\n      character: abbreviationRange.start.character,\n    },\n  })\n\n  // Worse case scenario is when cursor is inside a big chunk of text which needs to backtracked\n  // Backtrack only 500 offsets to ensure we dont waste time doing this\n  if (textToBackTrack.length > 500) {\n    textToBackTrack = textToBackTrack.substr(textToBackTrack.length - 500)\n  }\n\n  if (!textToBackTrack.trim()) {\n    return true\n  }\n\n  let valid = true\n  let foundSpace = false // If < is found before finding whitespace, then its valid abbreviation. E.g.: <div|\n  let i = textToBackTrack.length - 1\n  if (textToBackTrack[i] === startAngle) {\n    return false\n  }\n\n  while (i >= 0) {\n    const char = textToBackTrack[i]\n    i--\n    if (!foundSpace && /\\s/.test(char)) {\n      foundSpace = true\n      continue\n    }\n    if (char === question && textToBackTrack[i] === startAngle) {\n      i--\n      continue\n    }\n    // Fix for https://github.com/Microsoft/vscode/issues/55411\n    // A space is not a valid character right after < in a tag name.\n    if (/\\s/.test(char) && textToBackTrack[i] === startAngle) {\n      i--\n      continue\n    }\n    if (char !== startAngle && char !== endAngle) {\n      continue\n    }\n    if (i >= 0 && textToBackTrack[i] === escape) {\n      i--\n      continue\n    }\n    if (char === endAngle) {\n      if (i >= 0 && textToBackTrack[i] === '=') {\n        continue // False alarm of cases like =>\n      } else {\n        break\n      }\n    }\n    if (char === startAngle) {\n      valid = !foundSpace\n      break\n    }\n  }\n\n  return valid\n}\n","import { State } from './util/state'\nimport type { Hover, TextDocument, Position } from 'vscode-languageserver'\nimport { stringifyCss, stringifyConfigValue } from './util/stringify'\nimport dlv from 'dlv'\nimport { isCssContext } from './util/css'\nimport { findClassNameAtPosition, findHelperFunctionsInRange } from './util/find'\nimport { validateApply } from './util/validateApply'\nimport { getClassNameParts } from './util/getClassNameAtPosition'\nimport * as jit from './util/jit'\nimport { validateConfigPath } from './diagnostics/getInvalidConfigPathDiagnostics'\nimport { isWithinRange } from './util/isWithinRange'\n\nexport async function doHover(\n  state: State,\n  document: TextDocument,\n  position: Position\n): Promise<Hover> {\n  return (\n    (await provideClassNameHover(state, document, position)) ||\n    provideCssHelperHover(state, document, position)\n  )\n}\n\nfunction provideCssHelperHover(state: State, document: TextDocument, position: Position): Hover {\n  if (!isCssContext(state, document, position)) {\n    return null\n  }\n\n  let helperFns = findHelperFunctionsInRange(document, {\n    start: { line: position.line, character: 0 },\n    end: { line: position.line + 1, character: 0 },\n  })\n\n  for (let helperFn of helperFns) {\n    if (isWithinRange(position, helperFn.ranges.path)) {\n      let validated = validateConfigPath(\n        state,\n        helperFn.path,\n        helperFn.helper === 'theme' ? ['theme'] : []\n      )\n      let value = validated.isValid ? stringifyConfigValue(validated.value) : null\n      if (value === null) {\n        return null\n      }\n      return {\n        contents: { kind: 'markdown', value: ['```plaintext', value, '```'].join('\\n') },\n        range: helperFn.ranges.path,\n      }\n    }\n  }\n\n  return null\n}\n\nasync function provideClassNameHover(\n  state: State,\n  document: TextDocument,\n  position: Position\n): Promise<Hover> {\n  let className = await findClassNameAtPosition(state, document, position)\n  if (className === null) return null\n\n  if (state.jit) {\n    let { root, rules } = jit.generateRules(state, [className.className])\n\n    if (rules.length === 0) {\n      return null\n    }\n\n    return {\n      contents: {\n        language: 'css',\n        value: await jit.stringifyRoot(state, root, document.uri),\n      },\n      range: className.range,\n    }\n  }\n\n  const parts = getClassNameParts(state, className.className)\n  if (!parts) return null\n\n  if (isCssContext(state, document, position)) {\n    let validated = validateApply(state, parts)\n    if (validated === null || validated.isApplyable === false) {\n      return null\n    }\n  }\n\n  const settings = await state.editor.getConfiguration(document.uri)\n\n  const css = stringifyCss(\n    className.className,\n    dlv(state.classNames.classNames, [...parts, '__info']),\n    settings\n  )\n\n  if (!css) return null\n\n  return {\n    contents: {\n      language: 'css',\n      value: css,\n    },\n    range: className.range,\n  }\n}\n","import { State } from './util/state'\nimport {\n  findClassListsInDocument,\n  getClassNamesInClassList,\n  findHelperFunctionsInDocument,\n} from './util/find'\nimport { getColor, getColorFromValue, culoriColorToVscodeColor } from './util/color'\nimport { stringToPath } from './util/stringToPath'\nimport type { TextDocument, ColorInformation } from 'vscode-languageserver'\nimport dlv from 'dlv'\nimport { dedupeByRange } from './util/array'\n\nexport async function getDocumentColors(\n  state: State,\n  document: TextDocument\n): Promise<ColorInformation[]> {\n  let colors: ColorInformation[] = []\n  if (!state.enabled) return colors\n\n  let settings = await state.editor.getConfiguration(document.uri)\n  if (settings.tailwindCSS.colorDecorators === false) return colors\n\n  let classLists = await findClassListsInDocument(state, document)\n  classLists.forEach((classList) => {\n    let classNames = getClassNamesInClassList(classList)\n    classNames.forEach((className) => {\n      let color = getColor(state, className.className)\n      if (color === null || typeof color === 'string' || (color.alpha ?? 1) === 0) {\n        return\n      }\n      colors.push({\n        range: className.range,\n        color: culoriColorToVscodeColor(color),\n      })\n    })\n  })\n\n  let helperFns = findHelperFunctionsInDocument(state, document)\n  helperFns.forEach((fn) => {\n    let keys = stringToPath(fn.path)\n    let base = fn.helper === 'theme' ? ['theme'] : []\n    let value = dlv(state.config, [...base, ...keys])\n    let color = getColorFromValue(value)\n    if (color && typeof color !== 'string' && (color.alpha ?? 1) !== 0) {\n      colors.push({ range: fn.ranges.path, color: culoriColorToVscodeColor(color) })\n    }\n  })\n\n  return dedupeByRange(colors)\n}\n","import isObject from './isObject'\n\nexport type MinMaxScreen = {\n  min?: string\n  max?: string\n}\n\nexport type RawScreen = {\n  raw: string\n}\n\nexport type Screen = string | RawScreen | MinMaxScreen | MinMaxScreen[]\n\nfunction isRawScreen(screen: unknown): screen is RawScreen {\n  return isObject(screen) && (screen as RawScreen).raw !== undefined\n}\n\nexport function stringifyScreen(screen: Screen): string | undefined {\n  if (!screen) return undefined\n  if (typeof screen === 'string') return `@media (min-width: ${screen})`\n  if (isRawScreen(screen)) {\n    return `@media ${(screen as RawScreen).raw}`\n  }\n  let str = (Array.isArray(screen) ? screen : [screen])\n    .map((range) => {\n      return [\n        typeof range.min === 'string' ? `(min-width: ${range.min})` : null,\n        typeof range.max === 'string' ? `(max-width: ${range.max})` : null,\n      ]\n        .filter(Boolean)\n        .join(' and ')\n    })\n    .join(', ')\n  return str ? `@media ${str}` : undefined\n}\n"],"names":["isObject","variable","Object","prototype","toString","call","removeMeta","obj","result","key","substr","rangesEqual","a","b","start","line","character","end","dedupe","arr","filter","value","index","self","indexOf","dedupeByRange","classList","classListIndex","findIndex","c","range","ensureArray","Array","isArray","flatten","arrays","concat","apply","equal","length","aSorted","sort","bSorted","i","combinations","str","fn","active","rest","slice","push","getClassNameParts","state","className","separator","parts","replace","split","dlv","classNames","map","x","parseInt","p","forEach","join","find","remToPx","rootSize","test","number","parseFloat","isNaN","bigSign","bigIntValue","generateRules","rules","modules","jit","module","Set","jitContext","z","root","postcss","nodes","_ref3","rule","expandApplyAtRules","actualRules","walkRules","subRule","async","stringifyRoot","uri","settings","editor","getConfiguration","clone","walkAtRules","node","remove","tailwindCSS","showPixelEquivalents","walkDecls","decl","px","rootFontSize","_match","before","after","indent","repeat","tabSize","replaceClassName","selector","postcssSelectorParser","selectors","walkClasses","processSync","getRuleContext","context","parent","type","unshift","name","params","COLOR_PROPS","getKeywordColor","lowercased","toLowerCase","colorRegex","RegExp","keys","namedColors","getColorsInString","from","replaceColorVarsWithTheirDefaults","matchAll","match","color","culori","Boolean","getColorFromDecls","decls","props","prop","nonCustomProps","startsWith","areAllCustom","some","includes","colors","flatMap","colorStrings","alpha","undefined","keyword","nonKeywordColors","alphas","getColor","item","__rule","getColorFromValue","trimmedValue","trim","toRgb","culoriColorToVscodeColor","rgb","red","r","green","g","blue","htmlLanguages","cssLanguages","jsLanguages","isJsDoc","doc","userJsLanguages","userLanguages","lang","languageId","isJsxContext","position","getText","boundaries","getLanguageBoundaries","isCssDoc","userCssLanguages","isCssContext","isHtmlDoc","isVueDoc","isSvelteDoc","isWithinRange","lazy","getter","evaluated","_res","res","this","arguments","isLazy","classAttributeStates","doubleClassList","arb","lbrace","rbrace","pop","classlist","lineBreaks","singleClassList","tickClassList","interpBrace","startSingle","startDouble","startTick","text","interpSingle","single","interpDouble","double","arbitrary","space","arb2","simpleClassAttributeStates","main","getClassAttributeLexer","supportsNegativeLookbehind","_","moo","states","start1","start2","start3","getComputedClassAttributeLexer","resolveRange","relativeTo","getTextWithoutComments","docOrText","jsLexer","commentLine","commentBlock","stringDouble","stringSingle","stringBacktick","other","reset","token","getJsWithoutComments","char","findAll","re","matches","exec","getClassNamesInClassList","important","names","indexToPosition","relativeRange","findClassNamesInRange","mode","includeCustom","classLists","findClassListsInCssRange","findClassListsInHtmlRange","findCustomClassLists","findClassListsInRange","globalStart","groups","regexes","experimental","classRegex","containerMatch","containerRegexString","classRegexString","containerRegex","Regex","matchStart","offsetAt","matchEnd","classMatch","classMatchStart","classMatchEnd","positionAt","matchClassAttributes","attributes","attrs","source","classAttributes","subtext","lexer","endsWith","currentClassList","offset","_ref2","beforeOffset","afterOffset","findClassListsInDocument","Promise","all","_ref4","findHelperFunctionsInDocument","findHelperFunctionsInRange","_ref5","quotesBefore","path","m","startIndex","prefix","helper","innerPrefix","ranges","full","col","lineColumn","htmlScriptTypes","cssBlockStart","jsBlockStart","cssBlock","styleStart","next","cssBlockEnd","attrStartDouble","attrStartSingle","interp","jsBlock","scriptStart","jsBlockEnd","langAttrStartDouble","langAttrStartSingle","typeAttrStartDouble","typeAttrStartSingle","langAttrDouble","langAttrEnd","langAttrSingle","typeAttrDouble","typeAttrSingle","attrDouble","attrEnd","attrSingle","style","script","vueStates","htmlBlockStart","htmlBlock","htmlStart","htmlBlockEnd","html","nestedBlockStart","nestedBlock","nestedStart","nestedBlockEnd","nested","defaultLexer","vueLexer","cache","Cache","max","maxAge","cacheKey","cachedBoundaries","get","isJs","defaultType","set","userHtmlLanguages","isHtmlContext","stringifyConfigValue","stringifyObject","inlineCharacterLimit","Infinity","singleQuotes","transform","originalResult","stringifyCss","css","indentStr","reduce","acc","curr","val","pseudo","__pseudo","__scope","escapeClassName","augmentClassName","naturalExpand","total","gte","v1","v2","semverGte","docsUrl","version","paths","major","url","semver","getClassNameMeta","classNameOrParts","info","__source","scope","__context","flagEnabled","flag","featureFlags","future","config","validateApply","isApplyable","meta","reason","getVariantsFromClassName","allVariants","variants","variant","values","hasDash","input","stack","lastPos","idx","splitAtTopLevelOnly","part","add","completionsFromClassList","classListRange","partialClassName","subset","sep","subsetKey","isSubset","replacementRange","existingVariants","triggerKind","triggerCharacter","modifiers","beforeSlash","classListContainsMetadata","baseClassName","cls","_state$classList$find","_state$classList$find2","testClass","opacities","withDefaults","isIncomplete","items","modifier","documentation","kind","label","sortText","data","completionItemData","capabilities","itemDefaults","variantOrder","variantItem","_type","command","insertTextFormat","title","isArbitrary","textEditText","shouldSortVariants","resultingVariants","_ref","detail","additionalTextEdits","newText","__info","isUtil","k","isContextItem","NUMBER_REGEX","isNumber","completionList","defaults","supportedDefaults","defaultData","defaultRange","editRange","textEdit","DiagnosticKind","isCssConflictDiagnostic","diagnostic","code","CssConflict","isInvalidApplyDiagnostic","InvalidApply","isInvalidScreenDiagnostic","InvalidScreen","isInvalidVariantDiagnostic","InvalidVariant","isInvalidConfigPathDiagnostic","InvalidConfigPath","isInvalidTailwindDirectiveDiagnostic","InvalidTailwindDirective","isRecommendedVariantOrderDiagnostic","RecommendedVariantOrder","joinWithAnd","strings","cur","getClassNameDecls","getCssConflictDiagnostics","document","severity","lint","cssConflict","diagnostics","properties","conflictingClassNames","_className","otherClassName","otherRules","otherClassNames","message","conflictingClassName","relatedInformation","location","otherDecls","otherMeta","getInvalidApplyDiagnostics","invalidApply","closest","options","sift","absoluteRange","reference","getInvalidScreenDiagnostics","invalidScreen","screens","screen","suggestions","suggestion","getInvalidVariantDiagnostics","invalidVariant","possibleVariants","v","listStartIndex","variantStartIndex","rePropName","reEscapeChar","stringToPath","string","charCodeAt","quote","subString","pathToString","validateConfigPath","base","findAlternativePath","possibility","isValid","parentPath","parentValue","closestValidKey","altPath","String","Number","validKeys","validKey","getInvalidConfigPathDiagnostics","invalidConfigPath","helperFn","getInvalidTailwindDirectiveDiagnostics","invalidTailwindDirective","regex","notSemicolonLanguages","hasVariantsDirective","valid","suggestable","getRecommendedVariantOrderDiagnostics","recommendedVariantOrder","sortedVariants","equalExact","doValidate","only","validate","removeRangesFromString","rangeOrRanges","finder","origin","indexRanges","toIndex","charAt","indexRange","substring","IMPORTANT","unitless","box-flex","box-flex-group","column-count","flex","flex-grow","flex-positive","flex-shrink","flex-negative","font-weight","line-clamp","line-height","opacity","order","orphans","tab-size","widows","z-index","zoom","fill-opacity","stroke-dashoffset","stroke-opacity","stroke-width","atRule","parse","hasOwnProperty","postcssSourceToRange","column","enabled","documents","textDocument","d","getDiagnosticsFromCodeActionParams","cssRange","cssText","changes","totalClassNamesInClassList","classNameParts","classNameInfo","languageBoundaries","_languageBoundaries$f","plugin","_options","atRuleRange","ast","validatedBaseClassName","globalContexts","common","con","dset","pseudos","canTransform","transformedSelector","selectorParser","sel","append","appendPseudosToSelector","[object Object]","cssObjToAst","classNameToAst","insertedRule","outputIndent","ruleRange","documentIndent","detectIndent","raws","process","edit","provideInvalidApplyCodeActions","_state","provideCssConflictCodeActions","provideSuggestionCodeActions","then","dedupeBy","JSON","stringify","findLast","Math","_item$data","_item$data2","validated","provideAtApplyCompletions","tokens","last","provideClassAttributeCompletions","provideClassNameCompletions","separators","o","aIsNumber","zIsNumber","replaceDot","insertClosingBrace","commitCharacters","provideCssHelperCompletions","partial","provideCssDirectiveCompletions","provideScreenDirectiveCompletions","provideVariantsDirectiveCompletions","provideTailwindDirectiveCompletions","layer","layers","provideLayerDirectiveCompletions","valueBeforeLastSlash","lastIndexOf","valueAfterLastSlash","readDirectory","isDirectory","provideConfigDirectiveCompletions","positionOffset","searchRange","cursor","Error","provideCustomClassNameCompletions","emmetCompletions","isHtml","syntax","extractAbbreviationResults","emmetHelper","abbreviation","abbreviationRange","textToBackTrack","foundSpace","isValidLocationForEmmetAbbreviation","symbols","getDocumentSymbols","symbol","emmetItems","provideEmmetCompletions","_ref6","findClassNameAtPosition","contents","language","provideClassNameHover","helperFns","provideCssHelperHover","colorDecorators","_item$data3","_item$data4","raw","isRawScreen","min","stringifyScreen","_item$data5","_item$data6","_item$data7","stringifyDecls","getCssDetail"],"mappings":"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"}